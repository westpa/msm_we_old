

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>msm_we.msm_we &mdash; msm_we 0.1.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> msm_we
          

          
          </a>

          
            
            
              <div class="version">
                0.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">msm_we</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Installation/Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code_todos.html">TODOs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">msm_we</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>msm_we.msm_we</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for msm_we.msm_we</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Main module.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="n">__metaclass__</span> <span class="o">=</span> <span class="nb">type</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tqdm</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partialmethod</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="kn">import</span> <span class="n">IncrementalPCA</span> <span class="k">as</span> <span class="n">iPCA</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span> <span class="k">as</span> <span class="n">kmeans</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">MiniBatchKMeans</span> <span class="k">as</span> <span class="n">mini_kmeans</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">rich.logging</span> <span class="kn">import</span> <span class="n">RichHandler</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">RichHandler</span><span class="p">())</span>
<span class="n">log</span><span class="o">.</span><span class="n">propagate</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1"># Using the tkinter backend makes matplotlib run better on a cluster, maybe?</span>
<span class="c1"># import matplotlib</span>
<span class="c1"># matplotlib.use(&quot;TkAgg&quot;)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>
<span class="kn">import</span> <span class="nn">pyemma.coordinates</span> <span class="k">as</span> <span class="nn">coor</span>
<span class="kn">import</span> <span class="nn">pyemma.coordinates.clustering</span> <span class="k">as</span> <span class="nn">clustering</span>
<span class="kn">import</span> <span class="nn">pyemma</span>


<div class="viewcode-block" id="inverse_iteration"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.inverse_iteration">[docs]</a><span class="k">def</span> <span class="nf">inverse_iteration</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Do one iteration of inverse iteration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    guess: array-like  (N elements)</span>
<span class="sd">        Vector of weights to be used as the initial guess.</span>

<span class="sd">    matrix: array-like (NxN elements)</span>
<span class="sd">        Transition matrix to use for inverse iteration.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The new vector of weights after one iteration of inverse iteration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Looking for eigenvector corresponding to eigenvalue 1</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Inverse</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">identity</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">inverse</span> <span class="o">@</span> <span class="n">guess</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

    <span class="c1"># Normalize</span>
    <span class="n">result</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="modelWE"><a class="viewcode-back" href="../../stubs/msm_we.msm_we.modelWE.html#msm_we.msm_we.modelWE">[docs]</a><span class="k">class</span> <span class="nc">modelWE</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implementation of haMSM model building, particularly for steady-state estimation (but there are lots of extras),</span>
<span class="sd">    from WE sampling with basis (source) and target (sink) states with recycling.</span>

<span class="sd">    Set up for typical west.h5 file structure, with coordinates to be stored in west.h5 /iterations/auxdata/coord and</span>
<span class="sd">    basis and target definitions from progress coordinates.</span>

<span class="sd">    Check out run_msmWE.slurm and run_msmWE_flux.py in scripts folder for an implementation example.</span>

<span class="sd">    Danger</span>
<span class="sd">    -------</span>
<span class="sd">    This code currently, in general, appears to assume a 1-D progress coordinate.</span>

<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Refactor</span>
<span class="sd">        In general, this class&#39;s methods generally handle data by holding state in the object.</span>
<span class="sd">        The functions that update state with the result of a calculation, though, tend to update a lot of state on the way.</span>
<span class="sd">        The state being updated along the way is usually &quot;helper&quot; quantities (an example would be the number of bins</span>
<span class="sd">        or number of walkers, which is computed &quot;along the way&quot; in a number of functions, and the object state updated.)</span>

<span class="sd">        I think it would be prudent to refactor these in such a way that these are updated in as few places as possible --</span>
<span class="sd">        one example of this might be setting them as properties, and then updating the value in state as part of that</span>
<span class="sd">        accessor if necessary.</span>


<span class="sd">    References</span>
<span class="sd">    --------</span>
<span class="sd">    Copperman and Zuckerman,</span>
<span class="sd">    *Accelerated estimation of long-timescale kinetics by combining weighted ensemble simulation with Markov model</span>
<span class="sd">    microstategs using non-Markovian theory*, **arXiv** (2020).</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="modelWE.__init__"><a class="viewcode-back" href="../../stubs/msm_we.msm_we.modelWE.html#msm_we.msm_we.modelWE.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work-in-progress init function. For now, just start adding attribute definitions in here.</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        - Most logic from initialize() should be moved in here.</span>

<span class="sd">        - Also, comment all of these here. Right now most of them have comments throughout the code.</span>

<span class="sd">        - Reorganize these attributes into some meaningful structure</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Name used for storing files&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;list of str: List of all filenames with data&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of files in :code:`fileList`</span>

<span class="sd">        **TODO**: Deprecate this, this could just be a property&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of dimensions in the progress coordinate&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of stored progress coordinates for each iteration, per-segment.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Resampling time for weighted ensemble. (Maybe should be int? Units?)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">WEtargetp1_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WEtargetp1_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Progress coordinate value at target state.</span>
<span class="sd">        Used to check if a progress coord is in the target, and to set the RMSD of the target cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_WEtargetp1_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">WEbasisp1_min</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Minimum progress coordinate value within basis state.</span>
<span class="sd">        Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">WEbasisp1_max</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;float: Maximum progress coordinate value within basis state.</span>
<span class="sd">        Used to check if a progress coord is in the basis, and to set the RMSD of the basis cluster when cleaning the</span>
<span class="sd">        fluxmatrix.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_WEbasisp1_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Dimensionality reduction method. Must be one of &quot;pca&quot;, &quot;vamp&quot;, or &quot;none&quot; (**NOT** NoneType)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># For optimized binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;str: Test description for minwalkers&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># TODO: This is plural, reference_coord is singular. Intentional? Can you have multiple bases but 1 reference?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: Describe segindList better.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;list: List of segment indices(?)&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;array-like: List of segment weights in an iteration&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;int: Number of steps of history information to use when building transitions.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusterFile</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errorWeight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorCount</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;array-like: List of RMSDs corresponding to each cluster.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JtargetSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structures</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;dict: Mapping of cluster indices to structures in that cluster&quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="modelWE.initialize"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span>
        <span class="c1"># self, fileSpecifier: str, refPDBfile: str, initPDBfile: str, modelName: str</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fileSpecifier</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">refPDBfile</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">modelName</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">basis_pcoord_bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">target_pcoord_bounds</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dim_reduce_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pca&quot;</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pcoord_ndim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the model-builder.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileSpecifier : list</span>
<span class="sd">            List of paths to H5 files to analyze.</span>

<span class="sd">        refPDBfile : string</span>
<span class="sd">            Path to PDB file that defines topology.</span>

<span class="sd">        modelName : string</span>
<span class="sd">            Name to use in output filenames.</span>

<span class="sd">        basis_pcoord_bounds: list</span>
<span class="sd">            List of [lower bound, upper bound] in pcoord-space for the basis state</span>

<span class="sd">        target_pcoord_bounds: list</span>
<span class="sd">            List of [lower bound, upper bound] in pcoord-space for the target state</span>

<span class="sd">        dim_reduce_method: str</span>
<span class="sd">            Dimensionality reduction method. &quot;pca&quot;, &quot;vamp&quot;, or &quot;none&quot;.</span>

<span class="sd">        tau: float</span>
<span class="sd">            Resampling time (i.e. time of 1 WE iteration). Used to map fluxes to physical times.</span>

<span class="sd">        pcoord_ndim: int</span>
<span class="sd">            Defaults to 1. Dimensionality of progress coordinates.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>


<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Some of this logic should be broken into a constructor, and default arguments handled in the constructor&#39;s</span>
<span class="sd">        function signature.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Initializing msm_we model&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">=</span> <span class="n">modelName</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fileSpecifier</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">fileList</span> <span class="o">=</span> <span class="n">fileSpecifier</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">fileSpecifier</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">fileList</span> <span class="o">=</span> <span class="n">fileSpecifier</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;HDF5 file paths were provided in a string -- this is now deprecated, please pass as a list &quot;</span>
                <span class="s2">&quot;of paths.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span> <span class="o">=</span> <span class="n">pcoord_ndim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">basis_pcoord_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No basis coord bounds provided to initialize(). &quot;</span>
                <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">basis_pcoord_bounds</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">target_pcoord_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No target coord bounds provided to initialize(). &quot;</span>
                <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting basis pcoord bounds&quot;</span><span class="p">)</span>
            <span class="c1"># self.WEtargetp1_bounds = target_pcoord_bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span> <span class="o">=</span> <span class="n">target_pcoord_bounds</span>

        <span class="c1"># self._basis_pcoord_bounds = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span> <span class="o">=</span> <span class="n">fileList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileList</span><span class="p">)</span>
        <span class="c1">#####</span>

        <span class="k">if</span> <span class="n">tau</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No tau provided, defaulting to 1.&quot;</span><span class="p">)</span>
            <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>

        <span class="c1"># This is really only used for nAtoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_topology</span><span class="p">(</span><span class="n">refPDBfile</span><span class="p">)</span>
        <span class="c1"># self.set_basis(initPDBfile)</span>

        <span class="k">if</span> <span class="n">dim_reduce_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No dimensionality reduction method provided to initialize(). Defaulting to pca.&quot;</span>
                <span class="s2">&quot;You can manually set this for now, but that will be deprecated eventually.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="s2">&quot;pca&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">=</span> <span class="n">dim_reduce_method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="mi">48</span>  <span class="c1"># number of bins for optimized WE a la Aristoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">=</span> <span class="mi">40</span>  <span class="c1"># number of walkers for optimized WE a la Aristoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># minimum number of walkers per bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;adaptive&quot;</span>  <span class="c1"># adaptive for dynamic k-means bin edges, uniform for equal spacing on kh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;adaptive&quot;</span>  <span class="c1"># adaptive for dynamic allocation, uniform for equal allocation</span>
        <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates0</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Nothing is raised here because this might be fine, depending on what you&#39;re doing.</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Problem getting coordinates, they don&#39;t exist yet.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;msm_we model successfully initialized&quot;</span><span class="p">)</span></div>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">WEbasisp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@WEbasisp1_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">WEbasisp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the basis state in pcoord1, and also set the bin center based on those.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;WEbasisp1_bounds is a deprecated attribute. &quot;</span>
            <span class="s2">&quot;Set pcoord boundaries using basis_pcoord_bounds instead&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basis_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span>

    <span class="nd">@basis_pcoord_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">basis_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the basis state in an arbitrary dimension pcoord space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds: array-like, (pcoord_ndim x 2)</span>
<span class="sd">            Array of [lower, upper] bounds for each progress coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># In case it&#39;s a 1D pcoord provided as a simple list [min, max],</span>
        <span class="c1">#   reshape it to be consistent with N-D pcoord boundaries as  [[min, max]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Please provide 1-D boundaries as a list of lists or 2-D array&quot;</span>
                <span class="s2">&quot; [[lower bound, upper bound]]. Automatically doing conversion for now.&quot;</span>
            <span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">),</span> <span class="s2">&quot;Shape of bounds was </span><span class="si">{bounds.shape}</span><span class="s2">, should&#39;ve been (</span><span class="si">{self.pcoord_ndim}</span><span class="s2">, 2)&quot;</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;A boundary has a lower bound larger than its upper bound&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_basis_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

        <span class="n">basis_bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>

            <span class="c1"># If neither of the bin boundaries are infinity, then the bin center is their mean.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_max</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">basis_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">])</span>

            <span class="c1"># If one of them IS infinity, their &quot;bin center&quot; is the non-infinity one.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Janky indexing, if p1_max == inf then that&#39;s True, and True == 1 so it picks the second element</span>
                <span class="n">basis_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">][</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_centers</span> <span class="o">=</span> <span class="n">basis_bin_centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_lag</span>

    <span class="nd">@n_lag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">n_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lag</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Only a lag of 1 tau (n_lag = 0) is currently supported&quot;</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_lag</span> <span class="o">=</span> <span class="n">lag</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">WEtargetp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span>

    <span class="c1"># TODO: Deprecate this for an N-dimensional version</span>
    <span class="nd">@WEtargetp1_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">WEtargetp1_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the target state in pcoord1, and also set the bin center based on those.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;A target boundary has not been correctly provided&quot;</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;WEbasisp1_bounds is a deprecated attribute. &quot;</span>
            <span class="s2">&quot;Set pcoord boundaries using basis_pcoord_bounds instead&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

<div class="viewcode-block" id="modelWE.progress_disable"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.progress_disable">[docs]</a>    <span class="k">def</span> <span class="nf">progress_disable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disable all progress bars&quot;&quot;&quot;</span>
        <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.progress_enable"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.progress_enable">[docs]</a>    <span class="k">def</span> <span class="nf">progress_enable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable all progress bars&quot;&quot;&quot;</span>
        <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">partialmethod</span><span class="p">(</span><span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="o">.</span><span class="fm">__init__</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span>

    <span class="nd">@target_pcoord_bounds</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">target_pcoord_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the boundaries for the target state in an arbitrary dimension pcoord space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounds: array-like, (pcoord_ndim x 2)</span>
<span class="sd">            Array of [lower, upper] bounds for each progress coordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>

        <span class="c1"># In case it&#39;s a 1D pcoord provided as a simple list [min, max],</span>
        <span class="c1">#   reshape it to be consistent with N-D pcoord boundaries as  [[min, max]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Please provide 1-D boundaries as a list of lists or 2-D array&quot;</span>
                <span class="s2">&quot; [[lower bound, upper bound]]. Automatically doing conversion for now.&quot;</span>
            <span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">assert</span> <span class="n">bounds</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">,</span>
        <span class="p">),</span> <span class="s2">&quot;Shape of bounds was </span><span class="si">{bounds.shape}</span><span class="s2">, should&#39;ve been (</span><span class="si">{self.pcoord_ndim}</span><span class="s2">, 2)&quot;</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bound</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">bound</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bound</span> <span class="ow">in</span> <span class="n">bounds</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;A boundary has a lower bound larger than its upper bound&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_pcoord_bounds</span> <span class="o">=</span> <span class="n">bounds</span>

        <span class="n">target_bin_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds</span><span class="p">):</span>

            <span class="c1"># If neither of the bin boundaries are infinity, then the bin center is their mean.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bound_max</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">target_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">])</span>

            <span class="c1"># If one of them IS infinity, their &quot;bin center&quot; is the non-infinity one.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Janky indexing, if p1_max == inf then that&#39;s True, and True == 1 so it picks the second element</span>
                <span class="n">target_bin_centers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">bound_min</span><span class="p">,</span> <span class="n">bound_max</span><span class="p">][</span><span class="nb">abs</span><span class="p">(</span><span class="n">bound_min</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_centers</span> <span class="o">=</span> <span class="n">target_bin_centers</span>

<div class="viewcode-block" id="modelWE.initialize_from_h5"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.initialize_from_h5">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_from_h5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refPDBfile</span><span class="p">,</span> <span class="n">initPDBfile</span><span class="p">,</span> <span class="n">modelName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like initialize, but sets state without</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        refPDBfile</span>
<span class="sd">        initPDBfile</span>
<span class="sd">        modelName</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="modelWE.is_WE_basis"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.is_WE_basis">[docs]</a>    <span class="k">def</span> <span class="nf">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the input progress coordinates are in the basis state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pcoords : numpy.ndarray(num_segments, num_pcoords)</span>
<span class="sd">            Array of progress coordinates for each segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True or False : bool</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        This only checks the 0th progress coordinate</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pcoord_dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">):</span>
            <span class="n">in_basis</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">in_basis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">in_basis</span></div>

<div class="viewcode-block" id="modelWE.is_WE_target"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.is_WE_target">[docs]</a>    <span class="k">def</span> <span class="nf">is_WE_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pcoords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the input progress coordinates are in the target state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pcoords : numpy.ndarray(num_segments, num_pcoords)</span>
<span class="sd">            Array of progress coordinates for each segment.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        True or False : bool</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        This only checks the 0th progress coordinate</span>

<span class="sd">        This also assumes you need a small pcoord!</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pcoord_dimension</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">):</span>
            <span class="n">in_target</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="n">pcoords</span><span class="p">[:,</span> <span class="n">pcoord_dimension</span><span class="p">]</span>
                <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_pcoord_bounds</span><span class="p">[</span><span class="n">pcoord_dimension</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>

        <span class="n">in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">in_target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">in_target</span></div>

<div class="viewcode-block" id="modelWE.load_iter_data"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_iter_data">[docs]</a>    <span class="k">def</span> <span class="nf">load_iter_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update state with the data (including pcoord but not including coords) corresponding to an iteration.</span>

<span class="sd">        Object fields updated with the information from the selected iteration:</span>
<span class="sd">            - `self.westList`</span>
<span class="sd">            - `self.segindList`</span>
<span class="sd">            - `self.weightList`</span>
<span class="sd">            - `self.n_segs`</span>
<span class="sd">            - `self.pcoord0List`</span>
<span class="sd">            - `self.pcoord1List`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter : int</span>
<span class="sd">            Iteration to get data for.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        May want to rework the logic here, depending on how this is used.</span>
<span class="sd">        Seems like some of this iteration can be removed/optimized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># log.debug(&quot;Getting iteration data&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span>
        <span class="n">westList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">segindList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">weightList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>
        <span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">))</span>

        <span class="n">seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="n">n_segs</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Iterate through each file index, trying to find files that contains the iteration of interest</span>
        <span class="c1"># TODO: Can replace this with `for if, fileName in enumerate(self.\\)`</span>
        <span class="k">for</span> <span class="n">file_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">file_idx</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Try to find the h5 data file associated with this iteration</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

                <span class="c1"># Check if the dataset</span>
                <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>

                <span class="c1"># Check to make sure this isn&#39;t the last iteration -- last iterations have incomplete data</span>
                <span class="n">is_not_last_iteration</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dataIn</span>
                <span class="p">)</span>

                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From file </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2">, loading iteration </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">dataset_exists</span> <span class="ow">and</span> <span class="n">is_not_last_iteration</span><span class="p">:</span>

                    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                    <span class="n">n_segs_in_file</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                    <span class="n">n_segs_in_file</span> <span class="o">=</span> <span class="n">n_segs_in_file</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">dsetNameP</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dsetP</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetNameP</span><span class="p">]</span>
                    <span class="n">pcoord</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
                    <span class="n">weights</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
                    <span class="n">seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_weights</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>

                    <span class="c1"># Iterate over segments in this dataset</span>
                    <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_segs_in_file</span><span class="p">):</span>
                        <span class="c1"># if np.sum(pcoord[seg_idx,self.pcoord_len-1,:])==0.0:</span>
                        <span class="c1"># # intentionally using this to write in dummy pcoords,</span>
                        <span class="c1"># # this is a good thing to have for post-analysis though!</span>
                        <span class="c1">#    raise ValueError(&#39;Sum pcoord is 0, probably middle of WE iteration, not using iteration&#39;) f</span>
                        <span class="n">westList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">westList</span><span class="p">,</span> <span class="n">file_idx</span><span class="p">)</span>
                        <span class="n">segindList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segindList</span><span class="p">,</span> <span class="n">seg_idx</span><span class="p">)</span>
                        <span class="n">weightList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weightList</span><span class="p">,</span> <span class="n">newSet</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pcoord0List</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pcoord</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">pcoord1List</span><span class="p">,</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">pcoord</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">n_segs</span> <span class="o">=</span> <span class="n">n_segs</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">dataset_exists</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;error in &quot;</span> <span class="o">+</span> <span class="n">fileName</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">dataset_exists</span>

        <span class="c1"># log.debug(f&quot;Found {n_segs} segments in iteration {n_iter}&quot;)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">=</span> <span class="n">westList</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># This is a list of the segment indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">=</span> <span class="n">segindList</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span><span class="p">[</span><span class="n">n_iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span> <span class="o">=</span> <span class="n">weightList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span> <span class="o">=</span> <span class="n">n_segs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span> <span class="o">=</span> <span class="n">pcoord0List</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span> <span class="o">=</span> <span class="n">pcoord1List</span></div>

<div class="viewcode-block" id="modelWE.get_iterations"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iterations">[docs]</a>    <span class="k">def</span> <span class="nf">get_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with the maximum number of iterations, and the number of segments in each section.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        This updates :code:`numSegments` -- :code:`numSegments` is actually a *list* of the number of segments in each iteration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting number of iterations and segments&quot;</span><span class="p">)</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_iter</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Loop over nSegs</span>
        <span class="c1"># TODO: Not sure I understand the logic in this loop</span>
        <span class="k">while</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Iterate through each filename in fileList, and see if it contains the iteration we&#39;re looking for</span>
            <span class="c1"># TODO: This loop is pretty common, this should be refactored into a find_iteration() or something</span>
            <span class="k">for</span> <span class="n">file_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">file_index</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>

                    <span class="n">is_not_last_iteration</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dataIn</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">dataset_exists</span> <span class="ow">and</span> <span class="n">is_not_last_iteration</span><span class="p">:</span>
                        <span class="c1"># If this file does contain the iteration of interest</span>
                        <span class="c1"># if dataset_exists:</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                        <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                        <span class="n">nSeg</span> <span class="o">=</span> <span class="n">nS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nSeg</span>
                    <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No segments in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numSegments</span><span class="p">,</span> <span class="n">nSeg</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s2">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; has &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nSeg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; segments...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">n_iter</span> <span class="o">=</span> <span class="n">n_iter</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Warning: These are not defined until this is run for the first time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="n">numSegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="n">numSegments</span><span class="o">.</span><span class="n">size</span></div>

<div class="viewcode-block" id="modelWE.get_iterations_iters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iterations_iters">[docs]</a>    <span class="k">def</span> <span class="nf">get_iterations_iters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with the maximum number of iterations, and the number of segments in each section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter : int</span>
<span class="sd">        last_iter : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Warning</span>
<span class="sd">        ----</span>
<span class="sd">        This is potentially deprecated or unnecessary. Currently unused.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">n_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nSeg</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iF</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span><span class="p">):</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="n">dataset_exists</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">dataIn</span>
                    <span class="k">if</span> <span class="n">dataset_exists</span><span class="p">:</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">newSet</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                        <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">newSet</span><span class="p">)</span>
                        <span class="n">nSeg</span> <span class="o">=</span> <span class="n">nS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nSeg</span>
                    <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No segments in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nSeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">numSegments</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">numSegments</span><span class="p">,</span> <span class="n">nSeg</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; has &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nSeg</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; segments...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span> <span class="o">=</span> <span class="n">numSegments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="n">last_iter</span></div>

<div class="viewcode-block" id="modelWE.set_topology"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.set_topology">[docs]</a>    <span class="k">def</span> <span class="nf">set_topology</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topology</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with a new topology.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        topology : str</span>
<span class="sd">            Path to a file containing the PDB with the topology, OR, an mdtraj Trajectory object describing</span>
<span class="sd">            the new basis structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology was provided as a path, trying to load with mdtraj&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;dat&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;prmtop&quot;</span><span class="p">:</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load_prmtop</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">n_atoms</span>
                <span class="k">return</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">topology</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;pdb&quot;</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                    <span class="s2">&quot;Topology is not a recognized type (PDB)! Proceeding, but no guarantees.&quot;</span>
                <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_atoms</span>
            <span class="k">return</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology  was provided as an mdtraj structure, loading that&quot;</span>
            <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">topology</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">n_atoms</span></div>

<div class="viewcode-block" id="modelWE.set_basis"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.set_basis">[docs]</a>    <span class="k">def</span> <span class="nf">set_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">basis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates internal state with a new basis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        basis : str or mdtraj.Trajectory</span>
<span class="sd">            Path to a file containing the PDB with the new basis state, OR, an mdtraj Trajectory object describing</span>
<span class="sd">            the new basis structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input basis state topology was provided as a path, trying to load with mdtraj&quot;</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">basis</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;dat&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">basis</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="o">==</span> <span class="s2">&quot;pdb&quot;</span><span class="p">:</span>
                <span class="n">struct</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="n">struct</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                    <span class="s2">&quot;Basis is not a recognized type! Proceeding, but no guarantees.&quot;</span>
                <span class="p">)</span>
                <span class="c1"># raise NotImplementedError(&quot;Basis coordinates are not a recognized filetype&quot;)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Input reference topology  was provided as an mdtraj structure, loading that&quot;</span>
            <span class="p">)</span>

            <span class="n">struct</span> <span class="o">=</span> <span class="n">basis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_structure</span> <span class="o">=</span> <span class="n">struct</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">_xyz</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_transition_data"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_transition_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function analyzes pairs of coordinates at the current iteration, set by :code:`self.n_iter`, and at some</span>
<span class="sd">            lag in the past, :code:`self.n_iter - n_lag`.</span>

<span class="sd">        Segments where a walker was warped (recycled) use the basis coords as the lagged coords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_lag : int</span>
<span class="sd">            Number of lags to use for transitions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Getting transition data at arbitrary lags &gt; 0 is not yet supported! Use at your own risk.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># get segment history data at lag time n_lag from current iter</span>
        <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;too much lag for iter... n_lag reduced to: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n_lag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>
        <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;too much lag for stored history... recalculating...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="n">segindList_lagged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="n">n_lag</span><span class="p">]</span>

        <span class="c1"># TODO: What exactly is this a list of?</span>
        <span class="c1"># seg_histories is a list of indices of the segments</span>
        <span class="n">warpList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_lag</span><span class="p">]</span>  <span class="c1"># check for warps</span>
        <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">warpList</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get the weights for the lagged and current iterations</span>
        <span class="c1"># If something was split/merged between n_iter and n_iter-n_lag , then the weights may have changed, so</span>
        <span class="c1">#   check a particular segment&#39;s weight.</span>
        <span class="c1"># TODO: Does this effectively get the parent weight if it was split from something else? Then weight_histories</span>
        <span class="c1">#    would need to be tracking parents/children</span>
        <span class="n">weightList_lagged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[:,</span> <span class="n">n_lag</span><span class="p">]</span>
        <span class="c1"># TODO: Does this copy need to be made?</span>
        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>

        <span class="c1"># This will become a list of (lagged iter coord, current iter coord)</span>
        <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">prewarpedStructures</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">nWarped</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Go through each segment, and get pairs of coordinates at current iter (n_iter) and</span>
        <span class="c1"># lagged iter (n_iter-n_lag)</span>
        <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>

            <span class="c1"># FIXME: Try statements should encompass the smallest amount of code</span>
            <span class="c1">#  possible - anything could be tripping this</span>
            <span class="c1"># try:</span>
            <span class="k">if</span> <span class="n">seg_idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_current</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">n_lag</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_lagged</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># FIXME: I think you can just move this close to an if statement in the beginning, and then remove</span>
                <span class="c1">#   this whole if/elif. Everything after that close() seems to be duplicated.</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

                <span class="c1"># Load the data for the current iteration</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_current</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>

                <span class="c1"># Load the lagged data for (iteration - n_lag)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">n_lag</span>
                <span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coords_lagged</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>

            <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_current</span><span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
            <span class="p">]</span>

            <span class="c1"># If this segment has no warps, then add the lagged coordinates</span>
            <span class="k">if</span> <span class="n">warpList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Try to set the previous coord in the transition pair to the segment&#39;s lagged coordinates</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lagged_seg_index</span> <span class="o">=</span> <span class="n">segindList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
                    <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords_lagged</span><span class="p">[</span>
                        <span class="n">lagged_seg_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                    <span class="p">]</span>

                <span class="c1"># If this fails, then there were no lagged coordinates for this structure.</span>
                <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Lagged coordinates do not exist for the structure in segment </span><span class="si">{</span><span class="n">seg_idx</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">weightList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">weightList</span><span class="p">[</span>
                        <span class="n">seg_idx</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># set transitions without structures to zero weight</span>

            <span class="c1"># If something was recycled during this segment, then instead of using the lagged cooordinates,</span>
            <span class="c1">#   just use the basis coords.</span>
            <span class="c1"># But, also save the original structure before the warp!</span>
            <span class="k">elif</span> <span class="n">warpList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># St</span>
                <span class="n">prewarpedStructures</span><span class="p">[</span><span class="n">nWarped</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords_lagged</span><span class="p">[</span>
                    <span class="n">segindList_lagged</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                <span class="p">]</span>

                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="n">coordPairList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span>
                <span class="n">nWarped</span> <span class="o">=</span> <span class="n">nWarped</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># # TODO: What triggers this? When that critical log hits, come update this comment and the main docstring.</span>
            <span class="c1"># # This triggers on index out of bounds... But that&#39;s a huge try statement!</span>
            <span class="c1"># except Exception as e:</span>
            <span class="c1">#     log.critical(&quot;Document whatever&#39;s causing this exception!&quot;)</span>
            <span class="c1">#     log.warning(e)</span>
            <span class="c1">#     raise e</span>
            <span class="c1">#     weightList_lagged[seg_idx] = 0.0</span>
            <span class="c1">#     weightList[</span>
            <span class="c1">#         seg_idx</span>
            <span class="c1">#     ] = 0.0  # set transitions without structures to zero weight</span>

        <span class="c1"># Squeeze removes axes of length 1 -- this helps with np.where returning nested lists of indices</span>
        <span class="c1"># FIXME: is any of this necessary? This kinda seems like it could be replaced with</span>
        <span class="c1">#  something like indWarped = np.squeeze(np.where(warpList &gt; 0)).astype(int)</span>
        <span class="n">indWarped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">warpList</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">indWarpedArray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nWarped</span><span class="p">)</span>
        <span class="n">indWarpedArray</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nWarped</span><span class="p">]</span> <span class="o">=</span> <span class="n">indWarped</span>
        <span class="n">indWarped</span> <span class="o">=</span> <span class="n">indWarpedArray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Get the current and lagged weights</span>
        <span class="c1"># This returns (the wrong? none at all?) weights for segments with warps, which is corrected below</span>
        <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">weightList_lagged</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get correct weights for segments that warped</span>
        <span class="k">for</span> <span class="n">iW</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nWarped</span><span class="p">):</span>

            <span class="c1"># The coord pair here is (pre-warped structure, reference topology) instead of</span>
            <span class="c1">#   (lagged struture, current structure)</span>
            <span class="n">coordPair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">coordPair</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prewarpedStructures</span><span class="p">[</span><span class="n">iW</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">coordPair</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span>
            <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordPairList</span><span class="p">,</span> <span class="n">coordPair</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># TODO: iterWarped appears to be the iteration the warp happened at</span>
            <span class="n">iterWarped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">iterWarped</span><span class="p">)</span>
                <span class="n">iterWarped</span> <span class="o">=</span> <span class="n">iterWarped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot; warped &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nW</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; times</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># TODO: What exception is this handling? Why would this be tripped?</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Exception was </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="s2">&quot;UPDATE THIS EXCEPTION HANDLER!&quot;</span><span class="p">)</span>

                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    segment &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot; warped 1 time</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># The &quot;current&quot; weights are taken at the warp iteration, so the final pair of weights are</span>
            <span class="c1">#   (the lagged weights, the weights at the warp)</span>
            <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">transitionWeights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="n">iterWarped</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">departureWeights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span><span class="p">[</span><span class="n">indWarped</span><span class="p">[</span><span class="n">iW</span><span class="p">],</span> <span class="n">n_lag</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="n">coordPairList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">transitionWeights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="n">departureWeights</span></div>

<div class="viewcode-block" id="modelWE.get_transition_data_lag0"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_transition_data_lag0">[docs]</a>    <span class="k">def</span> <span class="nf">get_transition_data_lag0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get coordinate pairs at the beginning and end of this iteration.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.coordPairList, a list of  parent/child coordinate pairs</span>
<span class="sd">            - self.transitionWeights, a copy of self.weightList</span>
<span class="sd">            - self.departureWeights, a copy of self.weightList</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>
        <span class="n">coordPairList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting transition data for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segs in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, at a lag of 0&quot;</span>
        <span class="p">)</span>

        <span class="c1"># the segments in this iteration may be split across a number of different files</span>
        <span class="c1"># &quot;Traditionally&quot;, we store a reference for  each segment  of which WEST file it&#39;s in</span>
        <span class="c1"># But what if we flip that, and for each west file, get which segments are in it?</span>

        <span class="n">seg_west_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">)]</span>
        <span class="n">west_file_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_west_files</span><span class="p">)</span>
        <span class="n">west_files</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">west_file_idxs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">west_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">west_files</span><span class="p">):</span>

            <span class="n">segs_contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg_west_files</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">west_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>

                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">data_file</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">dset</span>

                <span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:</span>
                <span class="p">]</span>

                <span class="c1"># Check for NaNs in segments</span>
                <span class="n">nan_segments</span> <span class="o">=</span> <span class="n">segs_contained</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                    <span class="p">)</span>
                <span class="p">]</span>

                <span class="k">if</span> <span class="n">nan_segments</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Bad coordinates for segments </span><span class="si">{</span><span class="n">nan_segments</span><span class="si">}</span><span class="s2">, setting weights to 0&quot;</span>
                    <span class="p">)</span>
                    <span class="n">weightList</span><span class="p">[</span><span class="n">nan_segments</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">departureWeights</span> <span class="o">=</span> <span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span> <span class="o">=</span> <span class="n">coordPairList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span> <span class="o">=</span> <span class="n">transitionWeights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">departureWeights</span> <span class="o">=</span> <span class="n">departureWeights</span></div>

<div class="viewcode-block" id="modelWE.get_warps_from_parent"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_warps_from_parent">[docs]</a>    <span class="k">def</span> <span class="nf">get_warps_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all warps and weights over a range of iterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter: int</span>
<span class="sd">            First iteration in range.</span>
<span class="sd">        last_iter: int</span>
<span class="sd">            Last iteration in range.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        warpedWeights: list</span>
<span class="sd">            List of weights for each warp.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warpedWeights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">parentList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">parentList</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">warpedWeights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">warpedWeights</span></div>

    <span class="k">def</span> <span class="nf">get_warps_from_pcoord</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span>
    <span class="p">):</span>  <span class="c1"># get all warps and weights over set of iterations</span>
        <span class="n">warpedWeights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
            <span class="n">pcoord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># warpList = np.where(pcoord &lt; self.WEtargetp1)</span>
            <span class="n">warpList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="n">pcoord</span><span class="p">))</span>
            <span class="n">warpedWeights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span>
            <span class="n">meanJ</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">warpList</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;Jdirect: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">meanJ</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">warpedWeights</span>

    <span class="k">def</span> <span class="nf">get_direct_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">last_iter</span> <span class="o">-</span> <span class="n">first_iter</span>
        <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;/s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;/Jdirect&quot;</span>
        <span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">warpedWeights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_warps_from_pcoord</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">warpedWeights</span> <span class="o">=</span> <span class="n">warpedWeights</span>
            <span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">iS</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">iS</span> <span class="o">-</span> <span class="n">window</span>
                <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">nI</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
                <span class="n">warpedWeightsI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
                    <span class="n">warpedWeightsI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">warpedWeightsI</span><span class="p">,</span> <span class="n">warpedWeights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">nWarped</span> <span class="o">=</span> <span class="n">warpedWeightsI</span><span class="o">.</span><span class="n">size</span>
                <span class="n">particles</span> <span class="o">=</span> <span class="p">(</span><span class="n">nWarped</span> <span class="o">*</span> <span class="n">warpedWeightsI</span><span class="p">)</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">Jdirect</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span>
                <span class="n">JdirectTimes</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="n">iS</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">Jdirect</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Jdirect</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Jdirect</span>
            <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;/s&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;/JdirectTimes&quot;</span>
            <span class="p">)</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">JdirectTimes</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">JdirectTimes</span>
        <span class="k">elif</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">Jdirect</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;/s&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;_w&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;/JdirectTimes&quot;</span>
            <span class="p">)</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Jdirect</span> <span class="o">=</span> <span class="n">Jdirect</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_data_files</span>  <span class="c1"># correct for number of trees</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JdirectTimes</span> <span class="o">=</span> <span class="n">JdirectTimes</span>

<div class="viewcode-block" id="modelWE.get_seg_histories"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_seg_histories">[docs]</a>    <span class="k">def</span> <span class="nf">get_seg_histories</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_hist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **TODO: What does this do exactly?**</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.seg_histories</span>
<span class="sd">            - self.weight_histories</span>
<span class="sd">            - self.n_hist</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_hist : int</span>
<span class="sd">            Number of steps of history information to include.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting seg histories for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_hist</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;we have too much history... n_hist reduced to: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">n_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>

        <span class="c1"># FIXME: The only other place this is used is in get_transition_data(). May need to see how it&#39;s handled there</span>
        <span class="c1">#   i.e. make sure it&#39;s initialized</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">=</span> <span class="n">n_hist</span>

        <span class="n">seg_histories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">weight_histories</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span><span class="p">))</span>

        <span class="c1"># Loop over all segments</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>

            <span class="c1"># Print a message every 100 segments</span>
            <span class="c1"># if iS % 100 == 0:</span>
            <span class="c1">#     sys.stdout.write(</span>
            <span class="c1">#         &quot;        getting history for iteration &quot;</span>
            <span class="c1">#         + str(self.n_iter)</span>
            <span class="c1">#         + &quot; segment &quot;</span>
            <span class="c1">#         + str(iS)</span>
            <span class="c1">#         + &quot;...\n&quot;</span>
            <span class="c1">#     )</span>

            <span class="c1"># Open the relevant datafile for reading</span>
            <span class="k">if</span> <span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># If you&#39;re past the 0th segment, then close the previous file.</span>
                <span class="c1"># FIXME: Close the file after finished working with it, at the *end* of the loop. As-is, the last loop</span>
                <span class="c1">#       leaves the file open.</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>

            <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span>
            <span class="n">warped</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Iterate over history lengths from 1 to n_hist</span>
            <span class="k">for</span> <span class="n">iH</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hist</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

                <span class="n">indCurrentSeg</span> <span class="o">=</span> <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">indCurrentSeg</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                        <span class="s2">&quot;Segment &quot;</span>
                        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                        <span class="o">+</span> <span class="s2">&quot; warped last iter: History must end NOW!</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="n">warped</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">elif</span> <span class="n">indCurrentSeg</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">warped</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/seg_index&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span> <span class="o">-</span> <span class="n">iH</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>

                    <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="n">indCurrentSeg</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">weight_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[</span><span class="n">indCurrentSeg</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="n">seg_histories</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">iH</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="s2">&quot;            segment &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; warped &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iH</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; iters ago</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span> <span class="o">=</span> <span class="n">seg_histories</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_histories</span> <span class="o">=</span> <span class="n">weight_histories</span></div>
        <span class="c1"># FIXME:</span>
        <span class="c1">#   weight histories and segment histories go in reverse order,</span>
        <span class="c1">#   so final current iter is first of 0 index</span>

<div class="viewcode-block" id="modelWE.collect_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.collect_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">collect_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># grab coordinates from WE traj_segs folder</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Goes through the generated trajectory segments, and adds data from the segments to an H5 file.</span>

<span class="sd">        This should be implemented by the user, and this implementation assumes a really specific configuration.</span>
<span class="sd">        This is left in mostly as an example.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Generalize to different filetypes. This appears to be AMBER specific and relies on loading rst7 files</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;If you&#39;re calling this function, be absolutely sure it does what you want -- this is &quot;</span>
            <span class="s2">&quot;very specifically written for the output of certain simulations.&quot;</span>
        <span class="p">)</span>

        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="c1"># FIXME: Replace strings with Pathlib paths</span>
            <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
            <span class="n">WEfolder</span> <span class="o">=</span> <span class="n">westFile</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;west.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">trajpath</span> <span class="o">=</span> <span class="n">WEfolder</span> <span class="o">+</span> <span class="s2">&quot;traj_segs/</span><span class="si">%06d</span><span class="s2">/</span><span class="si">%06d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">iS</span><span class="p">)</span>
            <span class="n">coord0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                    <span class="n">trajpath</span> <span class="o">+</span> <span class="s2">&quot;/parent.rst7&quot;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span><span class="o">.</span><span class="n">topology</span>
                <span class="p">)</span><span class="o">.</span><span class="n">_xyz</span>
            <span class="p">)</span>
            <span class="n">coord1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">md</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
                    <span class="n">trajpath</span> <span class="o">+</span> <span class="s2">&quot;/seg.rst7&quot;</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_structure</span><span class="o">.</span><span class="n">topology</span>
                <span class="p">)</span><span class="o">.</span><span class="n">_xyz</span>
            <span class="p">)</span>
            <span class="n">coordT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord0</span><span class="p">,</span> <span class="n">coord1</span><span class="p">])</span>
            <span class="n">coordT</span> <span class="o">=</span> <span class="n">coordT</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coordT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">iS</span> <span class="o">&lt;</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>
                        <span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="c1"># TODO: Why exclude the last point?</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                                <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>
                            <span class="p">)</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                            <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                                <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:])</span>
                            <span class="p">)</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;coords exist for iteration &quot;</span>
                                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coordT</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>

                    <span class="c1"># If it&#39;s the last segment, don&#39;t exclude the last point (why?)</span>
                    <span class="k">elif</span> <span class="n">iS</span> <span class="o">==</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span>
                        <span class="p">)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                            <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                            <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
                            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coords</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                                <span class="s2">&quot;coords exist for iteration &quot;</span>
                                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                                <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                            <span class="p">)</span>

                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;error collecting coordinates from &quot;</span>
                    <span class="o">+</span> <span class="n">WEfolder</span>
                    <span class="o">+</span> <span class="s2">&quot; , iter &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iteration</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the valid coordinates for a certain iteration</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iteration: int</span>
<span class="sd">            The iteration to return coordinates for</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
        <span class="c1"># indGood = np.squeeze(np.where(np.sum(np.sum(self.cur_iter_coords, 2), 1) != 0))</span>

        <span class="n">bad_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_coords</span>

        <span class="c1"># iter_coords = self.cur_iter_coords[indGood]</span>
        <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">iter_coords</span></div>

<div class="viewcode-block" id="modelWE.load_iter_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_iter_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">load_iter_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Getting coordinates for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segs in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, at a lag of 0&quot;</span>
        <span class="p">)</span>

        <span class="c1"># the segments in this iteration may be split across a number of different files</span>
        <span class="c1"># &quot;Traditionally&quot;, we store a reference for  each segment  of which WEST file it&#39;s in</span>
        <span class="c1"># But flip that, and for each west file, get which segments are in it</span>

        <span class="n">seg_west_files</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">)]</span>
        <span class="n">west_file_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg_west_files</span><span class="p">)</span>
        <span class="n">west_files</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">west_file_idxs</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">west_file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">west_files</span><span class="p">):</span>

            <span class="n">segs_contained</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">seg_west_files</span> <span class="o">==</span> <span class="n">idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">west_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">data_file</span><span class="p">:</span>

                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">dset</span> <span class="o">=</span> <span class="n">data_file</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Error getting coordinates from </span><span class="si">{</span><span class="n">west_file</span><span class="si">}</span><span class="s2">, in iteration </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                    <span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="c1"># raise e</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">dset</span>
                    <span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">segs_contained</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">cur_iter_coords</span></div>

    <span class="k">def</span> <span class="nf">load_iter_coordinates0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># get iteration initial coordinates</span>
        <span class="n">coordList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iS</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
                <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
                <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/auxdata/coord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">dset</span><span class="p">[:]</span>
            <span class="n">coordList</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">coord</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span> <span class="o">=</span> <span class="n">coordList</span>

<div class="viewcode-block" id="modelWE.get_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unused</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        first_iter</span>
<span class="sd">        last_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;This function is not tested or supported, use at your own risk!&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span> <span class="o">=</span> <span class="n">first_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">=</span> <span class="n">last_iter</span>
        <span class="n">iters</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="n">iters</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">%</span> <span class="mi">50</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;    gathering structures from iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;...</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordsExist</span><span class="p">:</span>
                <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coordSet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_coords</span> <span class="o">=</span> <span class="n">coordSet</span></div>

<div class="viewcode-block" id="modelWE.get_coordSet"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_coordSet">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">streaming</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads all coordinates and progress coordinates into memory for later usage.</span>

<span class="sd">        If streaming, then this only loads pcoords</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        I want to avoid loading full coordinates into memory as much as possible.</span>
<span class="sd">        That means trying to replace usage of all_coords here.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        last_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">streaming</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">streaming</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CoordSet loading up to </span><span class="si">{</span><span class="n">last_iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">total_segments</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[:</span><span class="n">last_iter</span><span class="p">]))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
            <span class="n">coordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">total_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">pcoordSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">total_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord_ndim</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="n">last_seg_idx</span> <span class="o">=</span> <span class="n">total_segments</span>

        <span class="c1"># Update iterations N+1 -&gt; 1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">last_iter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Getting coordSet&quot;</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>

            <span class="n">first_seg_idx</span> <span class="o">=</span> <span class="n">last_seg_idx</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">first_seg_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Referencing a segment that doesn&#39;t exist&quot;</span>

            <span class="c1"># Get the indices of all &quot;good&quot; coordinates, where a  valid coordinate has been obtained</span>
            <span class="c1"># Boolean mask for coords that have been successfully initialized</span>
            <span class="n">bad_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">bad_coords</span>

            <span class="k">if</span> <span class="n">bad_coords</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Walker </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">bad_coords</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="si">}</span><span class="s2"> has bad coords in iteration(s) </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
                <span class="n">coordSet</span><span class="p">[</span><span class="n">first_seg_idx</span><span class="p">:</span><span class="n">last_seg_idx</span><span class="p">][</span>
                    <span class="n">good_coords</span>
                <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

            <span class="n">pcoordSet</span><span class="p">[</span><span class="n">first_seg_idx</span><span class="p">:</span><span class="n">last_seg_idx</span><span class="p">][</span><span class="n">good_coords</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span>
                <span class="n">good_coords</span><span class="p">,</span> <span class="p">:</span>
            <span class="p">]</span>

            <span class="n">last_seg_idx</span> <span class="o">=</span> <span class="n">first_seg_idx</span>

        <span class="c1"># Set the coords, and pcoords</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_coords</span> <span class="o">=</span> <span class="n">coordSet</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span> <span class="o">=</span> <span class="n">pcoordSet</span>

        <span class="n">first_iter_cluster</span> <span class="o">=</span> <span class="n">i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span> <span class="o">=</span> <span class="n">first_iter_cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span> <span class="o">=</span> <span class="n">last_iter</span></div>

    <span class="k">def</span> <span class="nf">get_traj_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_iter</span><span class="p">,</span> <span class="n">traj_length</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">traj_length</span> <span class="o">&gt;</span> <span class="n">from_iter</span><span class="p">:</span>
            <span class="n">traj_length</span> <span class="o">=</span> <span class="n">from_iter</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;trajectory length too long: set to &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">traj_length</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">from_iter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="n">traj_length</span><span class="p">)</span>
        <span class="n">traj_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">traj_length</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">traj_length</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">iH</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="n">westList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">from_iter</span><span class="p">,</span> <span class="n">from_iter</span> <span class="o">-</span> <span class="n">traj_length</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;    gathering structures from iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;...</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
            <span class="n">seg_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_histories</span><span class="p">[:,</span> <span class="n">iH</span><span class="p">]</span>
            <span class="n">seg_history_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nS</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nS</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="nb">int</span>
            <span class="p">)</span>  <span class="c1"># list of final iterations for warped particles</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nS</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">seg_history_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">segindList</span> <span class="o">==</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">westList</span> <span class="o">==</span> <span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">],</span>
                        <span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">][</span>
                        <span class="mi">0</span>
                    <span class="p">]</span>  <span class="c1"># segment indexes are local to the westfile, not global for the analysis set</span>
                    <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">seg_history</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">from_iter</span> <span class="o">-</span> <span class="n">traj_length</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">traj_iters</span><span class="p">[</span><span class="n">ic</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">[</span><span class="n">seg_history_index</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">iH</span> <span class="o">=</span> <span class="n">iH</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">from_iter</span><span class="p">)</span>
        <span class="n">traj_iters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">traj_iters</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj_iters</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="n">last_index</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span>

<div class="viewcode-block" id="modelWE.dimReduce"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.dimReduce">[docs]</a>    <span class="k">def</span> <span class="nf">dimReduce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dimensionality reduction using the scheme specified in initialization.</span>

<span class="sd">        This just defines the dimensionality reduction scheme -- it does NOT actually run it!</span>

<span class="sd">        Dimensionality reduction is actually performed via reduceCoordinates(), which uses self.coordinates as set</span>
<span class="sd">            by this.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.coordinates`</span>
<span class="sd">            - `self.ndim`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Todo</span>
<span class="sd">        ----</span>
<span class="sd">        Allow passing custom parameters to the dimensionality reduction schemes.</span>

<span class="sd">        Add `else` clause that raises a `NotImplemented` exception</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running dimensionality reduction -- method: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># log.debug(self.coordSet)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>

            <span class="c1"># Do this in a streaming way, iteration by iteration</span>
            <span class="c1"># First, do a &quot;rough&quot; PCA on the last 10% of the data to get the number of components that explain the</span>
            <span class="c1">#   variance cutoff.</span>
            <span class="c1"># This is necessary because with incremental PCA, there&#39;s no way to do this ahead of time.</span>
            <span class="n">variance_cutoff</span> <span class="o">=</span> <span class="mf">0.95</span>
            <span class="n">total_num_iterations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">)</span>
            <span class="n">first_iter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_num_iterations</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">))</span>
            <span class="n">rough_ipca</span> <span class="o">=</span> <span class="n">iPCA</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span><span class="p">,</span> <span class="n">total_num_iterations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Initial iPCA&quot;</span>
            <span class="p">):</span>
                <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                <span class="c1"># If  no good coords in this iteration, skip it</span>
                <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">processed_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                <span class="n">rough_ipca</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">processed_iter_coords</span><span class="p">)</span>

            <span class="n">components_for_var</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rough_ipca</span><span class="o">.</span><span class="n">explained_variance_ratio_</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">variance_cutoff</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keeping </span><span class="si">{</span><span class="n">components_for_var</span><span class="si">}</span><span class="s2"> components&quot;</span><span class="p">)</span>
            <span class="n">components_for_var</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">components_for_var</span><span class="p">,</span> <span class="n">total_num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Now do the PCA again, with that many components, using all the iterations.</span>
            <span class="n">ipca</span> <span class="o">=</span> <span class="n">iPCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">components_for_var</span><span class="p">)</span>

            <span class="n">_iter_coords</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;iPCA&quot;</span><span class="p">):</span>
                <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                <span class="c1"># If no good coords in this iteration, skip it</span>
                <span class="k">if</span> <span class="n">_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">continued</span><span class="p">:</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">_iter_coords</span>
                <span class="k">elif</span> <span class="n">continued</span><span class="p">:</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">components_for_var</span><span class="p">:</span>
                    <span class="n">continued</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>

                <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">processed_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                <span class="n">ipca</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">processed_iter_coords</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">ipca</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="n">components_for_var</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="c1"># TODO: I  don&#39;t think trajSet is initialized by itself -- you need to manually call get_traj_coordinates</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;VAMP dimensionality reduction requires you to *manually* call get_traj_coordinates first, &quot;</span>
                <span class="s2">&quot;or self.trajSet will be all None. Make sure you&#39;ve done that!&quot;</span>
            <span class="p">)</span>

            <span class="n">ntraj</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ntraj</span>
            <span class="k">for</span> <span class="n">itraj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ntraj</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">itraj</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajSet</span><span class="p">[</span><span class="n">itraj</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">vamp</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">lag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vamp_lag</span><span class="p">,</span>
                <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vamp_dim</span><span class="p">,</span>
                <span class="n">scaling</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">dimension</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">)</span>

            <span class="c1"># TODO: Why is this unused?</span>
            <span class="c1"># data = self.all_coords.reshape(-1, self.ndim)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Coordinates</span><span class="p">()</span></div>
            <span class="c1"># self.coordinates.transform=self.processCoordinates</span>

<div class="viewcode-block" id="modelWE.Coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.Coordinates">[docs]</a>    <span class="k">class</span> <span class="nc">Coordinates</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fake Coordinates class, in case you don&#39;t want to use either PCA or VAMP for dimensionality reduction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># The class &quot;constructor&quot; - It&#39;s actually an initializer</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">explanation</span> <span class="o">=</span> <span class="s2">&quot;coordinate object&quot;</span>

<div class="viewcode-block" id="modelWE.Coordinates.transform"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.Coordinates.transform">[docs]</a>        <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">coords</span></div></div>

    <span class="c1"># def processCoordinates(self, coords):</span>
<div class="viewcode-block" id="modelWE.processCoordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.processCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">processCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        User-overrideable function to process coordinates.</span>

<span class="sd">        This defines the featurization process.</span>
<span class="sd">        It takes in takes in an array of the full set of coordinates, and spits out an array of the feature coordinates.</span>
<span class="sd">        That array is then passed to functions like coor.pca(), coor.vamp(), or used directly if dimReduceMethod==&quot;none&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="modelWE.reduceCoordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.reduceCoordinates">[docs]</a>    <span class="k">def</span> <span class="nf">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This performs the dimensionality reduction.</span>

<span class="sd">        dimReduce() defines self.coordinates, which is an object that has a .transform() function that produces the</span>
<span class="sd">        reduced data.</span>

<span class="sd">        reduceCoordinates() actually uses that coordinates object, transforms the coordinates,</span>
<span class="sd">        and returns the reduced data.</span>

<span class="sd">        The reduced coordinates are then stored in /auxdata for each iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords: array-like</span>
<span class="sd">            Array of coordinates to reduce.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Reduced data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Reducing coordinates&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="n">nC</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nC</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">coords</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;dimReduceMethod undefined in reduceCoordinates&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.update_cluster_structures"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.update_cluster_structures">[docs]</a>    <span class="k">def</span> <span class="nf">update_cluster_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find structures (i.e. sets of coordinates) corresponding to each clusters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A dictionary where the keys are cluster indices, and the values are lists of coordinates (structures)</span>
<span class="sd">            in that cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Obtaining cluster structures...&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Clusters have not been computed!&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dtrajs len: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">)</span><span class="si">}</span><span class="s2">, [0] shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">cluster_structures</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="c1"># Move this elsewhere, WE segment weights are useful to have outside of this</span>
        <span class="n">all_seg_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">)),</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># total_num_iterations = len(self.numSegments)</span>
        <span class="n">total_num_iterations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span>
        <span class="c1"># Don&#39;t include the last iteration, where dynamics didn&#39;t run</span>
        <span class="k">for</span> <span class="n">_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">iter_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seg_weights</span><span class="p">[</span><span class="n">_iter</span><span class="p">]</span>

            <span class="c1"># This is an array, not a dict, so index by... well, index, and not iter_number</span>
            <span class="n">num_segs_in_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[</span><span class="n">_iter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># log.debug(f&quot;Found {num_segs_in_iter} in iter {_iter}&quot;)</span>
            <span class="c1"># log.debug(f&quot;Updating indices {i} :  {i + num_segs_in_iter}&quot;)</span>

            <span class="k">assert</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">iter_weights</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;None in iter </span><span class="si">{</span><span class="n">_iter</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">iter_weights</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">all_seg_weights</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">num_segs_in_iter</span><span class="p">]</span> <span class="o">=</span> <span class="n">iter_weights</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="n">num_segs_in_iter</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Got </span><span class="si">{</span><span class="n">all_seg_weights</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> seg weights&quot;</span><span class="p">)</span>

        <span class="c1"># Assign each segment to a cluster by iterating over coords</span>
        <span class="c1"># Track the &quot;absolute&quot; segment index because all_seg_weights is a flat list</span>
        <span class="n">seg_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total_num_iterations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

            <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>
            <span class="n">segs_in_iter</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numSegments</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">_seg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segs_in_iter</span><span class="p">):</span>

                <span class="c1"># log.debug(f&quot;Iteration {iteration}, segment {_seg}, segs in iter {segs_in_iter}&quot;)</span>
                <span class="c1"># iteration-1 because dtrajs has n_iterations-1 elements</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cluster_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="n">iteration</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">_seg</span><span class="p">]</span>

                <span class="c1"># This *should* trip if there was no data for this segments</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Tried to get dtraj for seg </span><span class="si">{</span><span class="n">_seg</span><span class="si">}</span><span class="s2"> at iteration </span><span class="si">{</span><span class="n">iteration</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;This dtraj point was in a removed cluster -- this should never happen!&quot;</span>
                    <span class="p">)</span>
                    <span class="c1"># log.debug(f&quot;Skipping cluster {cluster_idx}&quot;)</span>
                    <span class="c1"># continue</span>

                <span class="k">if</span> <span class="n">cluster_idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">cluster_structures</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">seg_coords</span> <span class="o">=</span> <span class="n">iter_coords</span><span class="p">[</span><span class="n">_seg</span><span class="p">]</span>
                <span class="n">cluster_structures</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_coords</span><span class="p">)</span>
                <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_seg_weights</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">])</span>

                <span class="n">seg_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">cluster_structure_weights</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">),</span> <span class="s2">&quot;Structures and weights have different numbers of bins?&quot;</span>

        <span class="n">test_cluster</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_structures</span><span class="p">[</span><span class="n">test_cluster</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">cluster_structure_weights</span><span class="p">[</span><span class="n">test_cluster</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;First MSM bin has different numbers of structures and weights&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structures</span> <span class="o">=</span> <span class="n">cluster_structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_structure_weights</span> <span class="o">=</span> <span class="n">cluster_structure_weights</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cluster structure mapping completed.&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster keys are </span><span class="si">{</span><span class="n">cluster_structures</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.cluster_coordinates"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.cluster_coordinates">[docs]</a>    <span class="k">def</span> <span class="nf">cluster_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">streaming</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">_cluster_args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use k-means to cluster coordinates into `n_clusters` cluster centers, and saves the resulting cluster object</span>
<span class="sd">        to a file.</span>

<span class="sd">        Saved cluster file is named</span>
<span class="sd">        &quot;&lt;`self.model_name`&gt;_clusters_s&lt;`self.first_iter`&gt;_e&lt;`self.last_iter`&gt;_nC&lt;`self.n_clusters`&gt;.h5&quot;</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.n_clusters`</span>
<span class="sd">            - `self.clusters`</span>
<span class="sd">            - `self.clusterFile`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_clusters: int</span>
<span class="sd">            Number of cluster centers to use.</span>

<span class="sd">        streaming: boolean</span>
<span class="sd">            Whether to stream k-means clustering, or load all from memory.</span>
<span class="sd">            Not supported for vamp dimensionality reduction.</span>

<span class="sd">        **_cluster_args:</span>
<span class="sd">            Keyword arguments that will be passed directly to cluster_kmeans</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Doing clustering on </span><span class="si">{</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">n_clusters</span>
        <span class="c1"># streaming = False</span>

        <span class="k">if</span> <span class="s2">&quot;metric&quot;</span> <span class="ow">in</span> <span class="n">_cluster_args</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="s2">&quot;k&quot;</span> <span class="ow">in</span> <span class="n">_cluster_args</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;You&#39;re passing pyemma-style arguments to k-means. K-means now uses sklearn, please update&quot;</span>
                <span class="s2">&quot;your code accordingly.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;PyEmma style arguments passed to kmeans, which is now based on sklearn&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set some default arguments, and overwrite them with the user&#39;s choices if provided</span>
        <span class="n">cluster_args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;n_clusters&quot;</span><span class="p">:</span> <span class="n">n_clusters</span><span class="p">,</span>
            <span class="s2">&quot;max_iter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">cluster_args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_cluster_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">streaming</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">mini_kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>
            <span class="c1"># TODO: Any mini_batch_kmeans specific arguments?</span>

        <span class="k">elif</span> <span class="n">streaming</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Streaming clustering is not supported for dimReduceMethod &#39;none&#39;. Using standard k-means.&quot;</span>
            <span class="p">)</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>
            <span class="n">streaming</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">cluster_model</span> <span class="o">=</span> <span class="n">kmeans</span><span class="p">(</span><span class="o">**</span><span class="n">cluster_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">streaming</span><span class="p">:</span>

                <span class="n">_data</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">_data</span><span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>

                <span class="c1"># Else here is a little sketchy, but fractional nAtoms is useful for some debugging hacks.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">_data</span>
                <span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">):</span>
                    <span class="n">_iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">continued</span><span class="p">:</span>
                        <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">_iter_coords</span>
                    <span class="k">elif</span> <span class="n">continued</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Appending </span><span class="si">{</span><span class="n">_iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> trajs for clustering&quot;</span>
                        <span class="p">)</span>
                        <span class="n">iter_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">,</span> <span class="n">_iter_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># This better pass, but just be sure.</span>
                    <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">cluster_model</span><span class="p">)</span> <span class="ow">is</span> <span class="n">mini_kmeans</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cluster_model</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                            <span class="s2">&quot;Not enough samples for the desired number of clusters, pulling&quot;</span>
                            <span class="s2">&quot;more iterations.&quot;</span>
                        <span class="p">)</span>
                        <span class="n">continued</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span>

                <span class="c1"># Now compute dtrajs from the final model</span>
                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">):</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAtoms</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span> <span class="ow">and</span> <span class="n">streaming</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering&quot;</span><span class="p">):</span>
                <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                <span class="c1"># Skip if  this is an empty iteration</span>
                <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">_transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">continued</span><span class="p">:</span>
                    <span class="n">transformed_coords</span> <span class="o">=</span> <span class="n">_transformed_coords</span>
                <span class="k">elif</span> <span class="n">continued</span><span class="p">:</span>
                    <span class="n">transformed_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">transformed_coords</span><span class="p">,</span> <span class="n">_transformed_coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>

                <span class="c1"># This better pass, but just be sure.</span>
                <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">cluster_model</span><span class="p">)</span> <span class="ow">is</span> <span class="n">mini_kmeans</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">partial_fit</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Not enough samples for the desired number of clusters, pulling&quot;</span>
                        <span class="s2">&quot;more iterations.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">continued</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">continued</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span>

            <span class="c1"># Now compute dtrajs from the final model</span>
            <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Discretization&quot;</span><span class="p">):</span>
                <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                <span class="c1"># Skip if  this is an empty iteration</span>
                <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span> <span class="ow">and</span> <span class="n">streaming</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;VAMP + streaming clustering is not supported.&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">streaming</span>
        <span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span><span class="p">:</span>
                <span class="n">transformed_data</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">):</span>
                    <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

                    <span class="c1"># Skip if  this is an empty iteration</span>
                    <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">transformed_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">))</span>
                    <span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Appended trajs for iter </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">stacked_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">transformed_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">stacked_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">transformed_data</span>
                <span class="p">]</span>

            <span class="c1"># TODO: Make sure this is returned in the shape (iteration, ...)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Clustering VAMP-reduced data still very experimental!&quot;</span><span class="p">)</span>

                <span class="n">transformed_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">get_output</span><span class="p">()</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">cluster_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">transformed_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">cluster_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">iter_trajs</span><span class="p">)</span> <span class="k">for</span> <span class="n">iter_trajs</span> <span class="ow">in</span> <span class="n">transformed_data</span>
                <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusterFile</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;_clusters_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_nC&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span>
        <span class="p">)</span>

        <span class="c1"># self.dtrajs = self.clusters.dtrajs</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Clustering completed.&quot;</span><span class="p">)</span></div>
        <span class="c1"># log.debug(f&quot;Dtrajs: {self.clusters.dtrajs}&quot;)</span>
        <span class="c1"># self.clusters.save(self.clusterFile, save_streaming_chain=True, overwrite=True)</span>

<div class="viewcode-block" id="modelWE.load_clusters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.load_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">load_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clusterFile</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load clusters from a file.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.clusters`</span>
<span class="sd">            - `self.n_clusters`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clusterFile: str</span>
<span class="sd">            Filename to load clusters from.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found saved clusters -- loading from </span><span class="si">{</span><span class="n">clusterFile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span> <span class="o">=</span> <span class="n">pyemma</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">clusterFile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="modelWE.get_iter_fluxMatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_fluxMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the flux matrix for an iteration.</span>

<span class="sd">        1. Update state with data from the iteration you want to compute the flux matrix for</span>
<span class="sd">        2. Load transition data at the requested lag</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        This function is slow because of the call to get_transition_data_lag0(). See that function for more info.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># 1. Update state with data from the iteration you want to compute the flux matrix for</span>
        <span class="c1"># sys.stdout.write(&quot;iteration &quot; + str(n_iter) + &quot;: data \n&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

        <span class="c1">#  2. Load transition data at the requested lag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If you&#39;re using more than 1 lag, obtain segment histories at that lag</span>
            <span class="c1">#   This means you have to look back one or more iterations</span>

            <span class="c1"># sys.stdout.write(&quot;segment histories \n&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_seg_histories</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># sys.stdout.write(&quot; transition data...\n&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_transition_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If you&#39;re using a lag of 0, your coordinate pairs are just the beginning/end of the iteration.</span>
            <span class="c1">#   In that, it&#39;s not possible to have warps/recycles, since those are done handled between iterations.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_transition_data_lag0</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No coordinates for iter </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2">, skipping this iter in fluxmatrix calculation&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting flux matrix for iter </span><span class="si">{</span><span class="n">n_iter</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="si">}</span><span class="s2"> segments&quot;</span><span class="p">)</span>
        <span class="c1"># If you used a lag of 0, transitions weights are just weightList</span>
        <span class="c1"># If you used a lag &gt; 0, these include the weight histories from previous iterations</span>
        <span class="c1"># num_transitions = np.shape(self.transitionWeights)[0]</span>

        <span class="c1"># Create dedicated clusters for the target and basis states,</span>
        <span class="c1"># and reassign any points within the target or basis to those</span>
        <span class="n">target_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">basis_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>

        <span class="c1"># (Segment, Atom, [lagged, current coord])</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coord pairlist shape is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Get which coords are not NaN</span>
        <span class="n">good_coords</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Assign a cluster to the lagged and the current coords</span>
        <span class="n">reduced_initial</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">reduced_final</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordPairList</span><span class="p">[</span><span class="n">good_coords</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">start_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">reduced_initial</span><span class="p">)</span>
        <span class="n">end_cluster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">reduced_final</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cluster 0 shape: </span><span class="si">{</span><span class="n">start_cluster</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Record every point where you&#39;re in the target</span>
        <span class="n">ind_end_in_target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_target</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">))</span>

        <span class="c1"># if indTarget1[0].size &gt; 0:</span>
        <span class="c1">#     log.debug(&quot;Number of post-transition target1 entries: &quot; + str(indTarget1[0].size) + &quot;\n&quot;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     log.warning(f&quot;No target1 entries. {indTarget1}&quot;)</span>

        <span class="c1"># Get the index of every point</span>
        <span class="n">ind_start_in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ind_start_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Number of pre-transition points in basis0: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind_start_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">ind_end_in_basis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_WE_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span><span class="n">good_coords</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ind_end_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Number of post-transition points in basis1: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ind_end_in_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Target cluster index is: </span><span class="si">{</span><span class="n">target_cluster_index</span><span class="si">}</span><span class="s2">,  basis cluster index is: </span><span class="si">{</span><span class="n">basis_cluster_index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Re-assign points that were in either the target or the basis to the target or basis clusters</span>
        <span class="n">end_cluster</span><span class="p">[</span><span class="n">ind_end_in_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_cluster_index</span>
        <span class="n">start_cluster</span><span class="p">[</span><span class="n">ind_start_in_basis</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_cluster_index</span>
        <span class="n">end_cluster</span><span class="p">[</span><span class="n">ind_end_in_basis</span><span class="p">]</span> <span class="o">=</span> <span class="n">basis_cluster_index</span>

        <span class="c1"># coo_matrix takes in (Data, (x, y)) and then gives you a matrix, with the point at Data[i]</span>
        <span class="c1">#   placed at (x,y)[i]</span>
        <span class="c1"># Data here is just the number of segments since each segment is associated with 1 transition</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transitionWeights</span><span class="p">[</span><span class="n">good_coords</span><span class="p">],</span> <span class="p">(</span><span class="n">start_cluster</span><span class="p">,</span> <span class="n">end_cluster</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>

        <span class="c1"># While the sparse matrix implementation is nice and efficient, using the np.matrix type is a little weird</span>
        <span class="c1">#   and fragile, and it&#39;s possible it&#39;ll be deprecated in the future.</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="o">.</span><span class="n">A</span>

        <span class="k">return</span> <span class="n">fluxMatrix</span></div>

    <span class="k">def</span> <span class="nf">get_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">binbounds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="n">dsetName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;/s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_b&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nBins</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;/pcoord1D_fluxMatrix&quot;</span>
        <span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>

        <span class="c1"># Again, disable this file</span>
        <span class="k">if</span> <span class="kc">True</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calling with </span><span class="si">{</span><span class="n">iS</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">binbounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="n">fluxMatrixI</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span>
                <span class="p">)</span>  <span class="c1"># correct for multiple trees</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
        <span class="k">elif</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nIter</span> <span class="o">=</span> <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">nIter</span> <span class="o">=</span> <span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nIter</span> <span class="o">&lt;</span> <span class="n">last_iter</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">n_lag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># TODO: Is this even implemented..?</span>
                        <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_lag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span>
                            <span class="n">iS</span><span class="p">,</span> <span class="n">binbounds</span>
                        <span class="p">)</span>
                    <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                    <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1D_fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span>

<div class="viewcode-block" id="modelWE.get_iter_pcoord1D_fluxMatrix_lag0"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_iter_pcoord1D_fluxMatrix_lag0">[docs]</a>    <span class="k">def</span> <span class="nf">get_iter_pcoord1D_fluxMatrix_lag0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_iter</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a flux-matrix in the space of the 1D progress coordinate, at a given iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_iter: integer</span>
<span class="sd">            Iteration to compute flux matrix for</span>

<span class="sd">        binbounds: array-like</span>
<span class="sd">            Array of progress coordinate bin boundaries</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The fluxmatrix at iteration n_iter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># log.info(n_iter)</span>
        <span class="c1"># log.info(binbounds)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;iteration &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;: solving fluxmatrix </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="n">n_iter</span><span class="p">)</span>

        <span class="n">weightList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">num_segments_in_iter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">nBins</span> <span class="o">=</span> <span class="n">binbounds</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nBins</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>

        <span class="c1"># Lists of all parent and child pcoords</span>
        <span class="n">pcoord0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">pcoord1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Assign parent/child pcoords to bins</span>
        <span class="n">bins0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">pcoord0</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>
        <span class="n">bins1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">pcoord1</span><span class="p">,</span> <span class="n">binbounds</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">seg_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_segments_in_iter</span><span class="p">):</span>
            <span class="c1"># I THINK WHAT&#39;S HAPPENING HERE IS:</span>
            <span class="c1"># The lowest binbound provided here should be smaller than the smallest possible</span>
            <span class="c1">#   value in the trajectory.</span>
            <span class="c1"># I.e., because of the way bins are defined for WE, you might have bin bounds like</span>
            <span class="c1">#   [0,1,2,3], where x&gt;3 is in the basis and 0&lt;x&lt;1 is in the target. However, digitize</span>
            <span class="c1">#   would assign a point of 0.5, which should be in the target, to index 1.</span>
            <span class="c1"># I think this -1 corrects for that.</span>

            <span class="n">from_bin_index</span> <span class="o">=</span> <span class="n">bins0</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">to_bin_index</span> <span class="o">=</span> <span class="n">bins1</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Set the weight of any segment that jumps more than 12 bins to 0?</span>
            <span class="c1">#   This seems super risky, and also originally this function didn&#39;t copy weightList, so it</span>
            <span class="c1">#   modified weightList in state for anything that runs after.</span>
            <span class="c1"># In particular, I think that&#39;s bad because if you have more than 12 bins, going from the target to</span>
            <span class="c1">#   the basis is going to be set to 0 by this logic.</span>
            <span class="c1"># So, I&#39;m going to disable this for now...</span>
            <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">from_bin_index</span> <span class="o">-</span> <span class="n">to_bin_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">12</span><span class="p">:</span>
                <span class="n">weightList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">from_bin_index</span><span class="p">,</span> <span class="n">to_bin_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">from_bin_index</span><span class="p">,</span> <span class="n">to_bin_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">weightList</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">fluxMatrix</span></div>

<div class="viewcode-block" id="modelWE.get_fluxMatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_fluxMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix of fluxes at a given lag time, for a range of iterations.</span>

<span class="sd">        Checks if a file has been written named</span>
<span class="sd">        &quot;&lt;`self.modelName`&gt;_s&lt;`first_iter`&gt;_e&lt;`last_iter`&gt;_lag&lt;`n_lag`&gt;_clust&lt;`self.n_clusters`&gt;.h5&quot;.</span>
<span class="sd">        If this file exists, load it and recalculate if it was calculated at an earlier iteration.</span>
<span class="sd">        Otherwise, write it.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.n_lag`</span>
<span class="sd">            - `self.errorWeight`</span>
<span class="sd">            - `self.errorCount`</span>
<span class="sd">            - `self.fluxMatrixRaw`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_lag: int</span>
<span class="sd">            Number of lags to use.</span>
<span class="sd">        first_iter: int</span>
<span class="sd">            First iteration to use.</span>
<span class="sd">        last_iter: int</span>
<span class="sd">            Last iteration to use.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing all flux matrices&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">=</span> <span class="n">n_lag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorWeight</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errorCount</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fluxMatrixParams</span> <span class="o">=</span> <span class="p">[</span><span class="n">n_lag</span><span class="p">,</span> <span class="n">first_iter</span><span class="p">,</span> <span class="n">last_iter</span><span class="p">]</span>

        <span class="c1"># +2 because the basis and target states are the last two indices</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">fileName</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;-fluxmatrix-_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_lag&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n_lag</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_clust&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Overwrite this file, don&#39;t try to read from it.  Hence the &quot;w&quot; flag</span>
        <span class="c1"># TODO: Maybe in the future return to this,</span>
        <span class="c1">#  but it caused more problems than it was worth when doing multiple runs.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span> <span class="o">+</span> <span class="s2">&quot;.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;fluxMatrix&quot;</span>

        <span class="c1"># FIXME: name this something descriptive or just use the &#39;in&#39; statement in the if/elif</span>
        <span class="n">fluxmatrix_exists_in_h5</span> <span class="o">=</span> <span class="n">dsetName</span> <span class="ow">in</span> <span class="n">f</span>
        <span class="n">always_overwrite_fluxmatrix</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># If this data file does not contain a fluxMatrix entry, create it</span>
        <span class="c1"># For now, don&#39;t use a saved fluxmatrix, annoying to debug</span>
        <span class="k">if</span> <span class="n">always_overwrite_fluxmatrix</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">fluxmatrix_exists_in_h5</span><span class="p">:</span>
            <span class="c1"># Create the fluxMatrix dataset</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">))</span>
            <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span>
            <span class="c1"># FIXME: Maybe just close this file after, I don&#39;t think it needs to be opened and closed this much</span>
            <span class="c1"># f.close()</span>

            <span class="c1"># Add up the flux matrices for each iteration to get the flux matrix.</span>
            <span class="c1"># Then, save that matrix to the data file, along with the number of iterations used</span>
            <span class="c1"># FIXME: Duplicated code</span>
            <span class="c1"># The range is offset by 1 because you can&#39;t calculate fluxes for the 0th iteration</span>
            <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">first_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Constructing flux matrix&quot;</span>
            <span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;getting fluxMatrix iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># f = h5py.File(fileName + &quot;.h5&quot;, &quot;a&quot;)</span>
                <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Completed flux matrix for iter </span><span class="si">{</span><span class="n">iS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="c1"># Normalize the flux matrix by the number of iterations that it was calculated with</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>

        <span class="c1"># If this datafile DOES contain a fluxMatrix entry...</span>
        <span class="c1"># This should never run now.</span>
        <span class="k">elif</span> <span class="n">fluxmatrix_exists_in_h5</span><span class="p">:</span>

            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fluxmatrix already exists in h5 file, loading saved.&quot;</span><span class="p">)</span>

            <span class="c1"># Load the existing fluxMatrix</span>
            <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
            <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">dsetP</span><span class="p">[:]</span>
            <span class="n">nIter</span> <span class="o">=</span> <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span>
            <span class="c1"># f.close()</span>
            <span class="n">nI</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># If the flux matrix was calculated at an earlier iteration than the current/requested last iteration, then</span>
            <span class="c1">#   recalculate it and update it.</span>
            <span class="c1"># TODO: Check if first_iter changed too? That&#39;s not stored anywhere</span>

            <span class="c1">#  For now, just always overwrite any saved data.</span>
            <span class="c1"># if nIter &lt; last_iter:</span>
            <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring any saved fluxmatrix in </span><span class="si">{</span><span class="n">fileName</span><span class="si">}</span><span class="s2">.h5&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nIter</span><span class="p">,</span> <span class="n">last_iter</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">fluxMatrixI</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_fluxMatrix</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
                    <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">+</span> <span class="n">fluxMatrixI</span>
                    <span class="n">nI</span> <span class="o">=</span> <span class="n">nI</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># f = h5py.File(fileName + &quot;.h5&quot;, &quot;a&quot;)</span>
                    <span class="n">dsetP</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                    <span class="n">dsetP</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>
                    <span class="n">dsetP</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;iter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iS</span>
                    <span class="c1"># f.close()</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;getting fluxMatrix iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">nI</span>

        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Update state with the new, updated, or loaded from file fluxMatrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span> <span class="o">=</span> <span class="n">fluxMatrix</span></div>

<div class="viewcode-block" id="modelWE.organize_fluxMatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.organize_fluxMatrix">[docs]</a>    <span class="k">def</span> <span class="nf">organize_fluxMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do some cleaning on the flux matrix, and update state with the cleaned flux matrix.</span>

<span class="sd">        Namely:</span>
<span class="sd">            - Remove unvisited clusters</span>
<span class="sd">            - Remove bins with no connectivity</span>
<span class="sd">            - Sort along the bins&#39; projection in pcoord 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        TODO</span>
<span class="sd">        ----</span>
<span class="sd">        Need to update self.cluster_structures with the new, reduced set of clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cleaning flux matrix&quot;</span><span class="p">)</span>

        <span class="c1"># Discretize trajectories via clusters</span>
        <span class="c1"># Get the indices of the target and basis clusters</span>
        <span class="n">target_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Target at -1</span>
        <span class="n">basis_cluster_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span>  <span class="c1"># basis at -2</span>

        <span class="c1"># This tracks which clusters are going to be cleaned from the flux matrix.</span>
        <span class="c1"># A 0 means it&#39;ll be cleaned, a 1 means it&#39;ll be kept.</span>
        <span class="n">good_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">cluster_pcoord_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># cluster_pcoord_centers[indTargetCluster]=self.target_rmsd</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_bin_center</span>
        <span class="c1"># cluster_pcoord_centers[indBasisCluster]=self.get_reference_rmsd(self.basis_coords)</span>
        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis_bin_center</span>

        <span class="c1"># Just initialize this to some positive nonzero value to kick off the while loop</span>
        <span class="n">nTraps</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="n">fluxMatrixTraps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">nTraps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nTraps</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">cluster_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">):</span>
                <span class="c1"># Get the indices of the dtraj points in this cluster</span>
                <span class="n">idx_traj_in_cluster</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj</span> <span class="o">==</span> <span class="n">cluster_index</span><span class="p">)</span> <span class="k">for</span> <span class="n">dtraj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span>
                <span class="p">]</span>

                <span class="c1"># Get the pcoord points that correspond to these dtraj points</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">pcoord_indices</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_traj_in_cluster</span><span class="p">):</span>
                    <span class="n">pcoord_idxs</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">pcoord_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pcoord_idxs</span><span class="p">)</span>
                    <span class="n">offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                <span class="c1"># Get the number of dtraj points in this cluster</span>
                <span class="n">n_in_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">idx_traj_in_cluster</span><span class="p">])</span>

                <span class="c1"># If this cluster is unvisited in the trajectories, set good_cluster to False</span>
                <span class="c1"># if np.shape(idx_traj_in_cluster)[1] == 0:</span>
                <span class="k">if</span> <span class="n">n_in_cluster</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Otherwise, get the average pcoord of the points in the cluster</span>
                <span class="k">elif</span> <span class="n">n_in_cluster</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># cluster_pcoord_centers[iC]=np.mean(self.get_reference_rmsd(self.coordSet[idx_traj_in_cluster[0],:,:]))</span>
                    <span class="c1"># The coordinate of this cluster center is the average pcoord of all points in it</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">pcoordSet</span><span class="p">[</span><span class="n">pcoord_indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Offset is </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">pcoord_indices</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>

                <span class="c1"># Get the total flux along the row and col of this index</span>
                <span class="n">net_flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrixTraps</span><span class="p">[:,</span> <span class="n">cluster_index</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="p">:]</span>
                <span class="p">)</span>

                <span class="c1"># If both the row and column are all zero, this is an unvisited state, so set good_clusters to 0/False</span>
                <span class="k">if</span> <span class="n">net_flux</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># If the sum along the row and column are nonzero</span>
                <span class="k">if</span> <span class="n">net_flux</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Get all the clusters that *aren&#39;t* the one we&#39;re looking at</span>
                    <span class="n">all_other_cluster_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                        <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">),</span> <span class="n">cluster_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Look at all the flux FROM other clusters</span>
                    <span class="n">total_flux_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="n">all_other_cluster_indices</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># And look at all the flux TO other clusters</span>
                    <span class="n">total_flux_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">all_other_cluster_indices</span><span class="p">,</span> <span class="n">cluster_index</span><span class="p">]</span>
                    <span class="p">)</span>

                    <span class="c1"># If either the flux from or the flux to other clusters are all zero,</span>
                    <span class="c1">#   then this is a source or sink respectively.</span>
                    <span class="c1"># So, clean it</span>
                    <span class="k">if</span> <span class="n">total_flux_in</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">total_flux_out</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">nTraps</span> <span class="o">=</span> <span class="n">nTraps</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="n">good_clusters</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[:,</span> <span class="n">cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">fluxMatrixTraps</span><span class="p">[</span><span class="n">cluster_index</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># Make sure we don&#39;t clean the target or basis clusters</span>
            <span class="n">good_clusters</span><span class="p">[</span><span class="n">basis_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">good_clusters</span><span class="p">[</span><span class="n">target_cluster_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Store this array. 1 if a cluster is good, 0 otherwise.</span>
        <span class="n">clusters_good</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">good_clusters</span><span class="p">)</span>

        <span class="c1"># Get all the visited and non-trap clusters, which we want to keep, and make fluxMatrix from those</span>
        <span class="n">good_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">good_clusters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrixRaw</span><span class="p">[</span><span class="n">good_clusters</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">good_clusters</span><span class="p">]</span>

        <span class="c1"># Get the RMSD centers for all of the clusters we want to keep</span>
        <span class="n">cluster_pcoord_centers</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">good_clusters</span><span class="p">]</span>
        <span class="c1"># Get the indices that sort it</span>
        <span class="n">pcoord_sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">cluster_pcoord_centers</span><span class="p">)</span>
        <span class="c1"># And update the model&#39;s RMSD cluster centers to just include the sorted clusters to keep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="c1"># Sort fluxmatrix using the sorted indices, columns and then rows</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">pcoord_sort_indices</span><span class="p">]</span>

        <span class="c1"># Renormalize the new flux matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">fluxMatrix</span>
        <span class="p">)</span>  <span class="c1"># average weight transitioning or staying put should be 1</span>

        <span class="c1"># Update the index of the basis and target states to account for their position in the new sorted clusters</span>
        <span class="n">originalClusters</span> <span class="o">=</span> <span class="n">good_clusters</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Good clusters: </span><span class="si">{</span><span class="n">good_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">originalClusters</span> <span class="o">==</span> <span class="n">basis_cluster_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">originalClusters</span> <span class="o">==</span> <span class="n">target_cluster_index</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;indBasis:  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="si">}</span><span class="s2">, indTargets: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sanity check -- basis:  </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span><span class="si">}</span><span class="s2">, target: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRMSD_centers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Save the new, sorted clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span> <span class="o">=</span> <span class="n">originalClusters</span>

        <span class="c1"># Update binCenters with the new, sorted centers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span> <span class="o">=</span> <span class="n">cluster_pcoord_centers</span><span class="p">[</span><span class="n">pcoord_sort_indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Remove the cluster structure dict entries corresponding to removed clusters</span>
        <span class="n">removed_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">clusters_good</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Good clusters are </span><span class="si">{</span><span class="n">clusters_good</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Removed clusters were </span><span class="si">{</span><span class="n">removed_clusters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="n">removed_clusters</span>

        <span class="c1"># TODO: Since I re-discretize below, this is no longer necessary.</span>
        <span class="c1">#  For now, set it to 1:1 for backwards compatibility</span>
        <span class="c1"># After cleaning, the cluster indices may no longer be consecutive.</span>
        <span class="c1">#  So, when I do the cleaning, I need to build a mapping of old, nonconsecutive cluster indices from the</span>
        <span class="c1">#  non-cleaned matrix, to new, consecutive indices.</span>
        <span class="c1"># That&#39;s like collapsing the nonconsecutive list. In other words, imagine I started with 5 clusters [0,1,2,3,4]</span>
        <span class="c1">#   and clean cluster 2. Now, I&#39;ll still have clusters labeled as [0,1,3,4], but my steady-state distribution</span>
        <span class="c1">#   is only 4 elements. So indexing element 4 won&#39;t do anything.</span>
        <span class="n">cluster_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)}</span>
        <span class="n">n_removed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cluster_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span><span class="p">:</span>
                <span class="n">n_removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">cluster_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_mapping</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_removed</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New cluster mapping is  </span><span class="si">{</span><span class="n">cluster_mapping</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mapping</span> <span class="o">=</span> <span class="n">cluster_mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cluster_mapping</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="c1"># Remove the bad clusters from the set of cluster centers. Thus, they won&#39;t be used by self.clusters.predict</span>
        <span class="c1">#   in the future.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">removed_clusters</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>

        <span class="c1"># TODO: You don&#39;t actually need to rediscretize every point -- just the removed ones.  Do this  later to make</span>
        <span class="c1">#   this more efficient.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxIter</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Post-cleaning rediscretization&quot;</span>
        <span class="p">):</span>
            <span class="n">iter_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_iter_coordinates</span><span class="p">(</span><span class="n">iteration</span><span class="p">)</span>

            <span class="c1"># Skip if  this is an empty iteration</span>
            <span class="k">if</span> <span class="n">iter_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">transformed_coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">processCoordinates</span><span class="p">(</span><span class="n">iter_coords</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dtrajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">transformed_coords</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">removed_clusters</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Update self.n_clusters to account for any removed clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">-=</span> <span class="n">n_removed</span>

        <span class="c1"># Rebuild the fluxmatrix with whatever params were originally provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_fluxMatrix</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_fluxMatrixParams</span><span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_model_clusters"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_model_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_model_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used by get_iter_aristoffian(). Untested and un-debugged, use at your own risk.</span>

<span class="sd">        Updates:</span>
<span class="sd">        - self.model_clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define new clusters from organized flux matrix corresponding to model</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;This function is untested, and may rely on other untested parts of this code. Use with extreme caution.&quot;</span>
        <span class="p">)</span>

        <span class="n">clustercenters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
        <span class="n">clustercenters</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clusters</span><span class="o">.</span><span class="n">clustercenters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span><span class="p">])</span>
            <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span>
                <span class="n">coords</span>
            <span class="p">)</span>  <span class="c1"># add in basis and target</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span><span class="p">,</span> <span class="p">:]),</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;pca&quot;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimReduceMethod</span> <span class="o">==</span> <span class="s2">&quot;vamp&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">basis_coords</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_coord</span><span class="p">),</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">coords</span>
            <span class="p">)</span>  <span class="c1"># add in basis and target</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">clustercenters</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">originalClusters</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="modelWE.get_Tmatrix"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_Tmatrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_Tmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the transition matrix from the flux matrix.</span>
<span class="sd">        Corrects the &quot;target&quot; states to be true sink states.</span>

<span class="sd">        More specifically:</span>
<span class="sd">            - row-normalizes the flux matrix,</span>
<span class="sd">            - sets any states with 0 flux ot (i.e. sinks) to have 1.0</span>
<span class="sd">            - sets target bins to uniformly recycle into basis bins</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.Tmatrix`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing transition matrix&quot;</span><span class="p">)</span>

        <span class="c1"># Get a copy of the flux matrix</span>
        <span class="n">fluxmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Get the dimension of the flux matrix</span>
        <span class="n">fluxmatrix_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fluxmatrix</span><span class="p">)</span>
        <span class="c1"># Add up the total flux on each row, i.e. from each state</span>
        <span class="n">fluxes_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxmatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># For each state</span>
        <span class="k">for</span> <span class="n">state_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fluxmatrix_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># For positive definite flux, set the matrix elements based on normalized fluxes</span>
            <span class="k">if</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="c1"># If the flux is zero, then consider it all self-transition</span>
            <span class="c1"># FIXME: this if can be an elif</span>
            <span class="k">if</span> <span class="n">fluxes_out</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">fluxmatrix</span><span class="p">[</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">state_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># Make the transition matrix a steady-state matrix</span>
        <span class="c1"># Identify the bins corresponding to target states.</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span>  <span class="c1"># np.where(avBinPnoColor==0.0)</span>

        <span class="c1"># Get the number of sink bins</span>
        <span class="n">n_sink_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sinkBins</span><span class="p">)</span>
        <span class="n">n_sink_bins</span> <span class="o">=</span> <span class="n">n_sink_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO: The goal here is to correct for the transition probabilities out of the sink state. Not</span>
        <span class="c1">#   sure I fully understand this implementation, but that&#39;s the goal.</span>
        <span class="c1"># Correction: I think this sets all the sink bins to recycle to the basis</span>
        <span class="n">sinkRates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">sinkRates</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="o">.</span><span class="n">size</span>
        <span class="n">tmatrix</span> <span class="o">=</span> <span class="n">fluxmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">tmatrix</span><span class="p">[</span><span class="n">sinkBins</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">sinkRates</span><span class="p">,</span> <span class="p">(</span><span class="n">n_sink_bins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">tmatrix</span></div>

    <span class="k">def</span> <span class="nf">get_eqTmatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">indSpace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">indSpace</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">indSpace</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">))</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">indSpace</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[:,</span> <span class="n">indSpace</span><span class="p">]</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
        <span class="n">sM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nR</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">Mt</span>

<div class="viewcode-block" id="modelWE.get_steady_state"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flux_fractional_convergence</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">        Get the steady-state distribution for the transition matrix.</span>
<span class="sd">        Uses scipy eigensolver to obtain an initial guess, then refines that using inverse iteration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flux_fractional_convergence: (optional, default=1e-4) float</span>
<span class="sd">            Convergence of the</span>

<span class="sd">        max_iters: (optional, default=100) int</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Transition matrices generated from WE data may have entries spanning many orders of magnitude, and may have</span>
<span class="sd">        extremely high condition numbers.</span>
<span class="sd">        Furthermore, the smallest entries may be those near the target state, which are also the most important</span>
<span class="sd">        for computing target fluxes, meaning values near machine precision can&#39;t just be truncated.</span>
<span class="sd">        All this means that floating-point error may substantially affect the results of eigensolvers, and may produce</span>
<span class="sd">        bad/negative/inaccurate values for small probability bins.</span>

<span class="sd">        In order to obtain better estimates, sparse matrices are used to reduce the number of floating point operations</span>
<span class="sd">        being performed.</span>
<span class="sd">        A stationary distribution is first estimated using scipy&#39;s eigensolver for sparse matrices.</span>
<span class="sd">        This is then used as an initial guess for the inverse iteration method, to further refine it.</span>
<span class="sd">        Convergence of the inverse iteration is determined using change in the flux estimate.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Cast the matrix to a sparse matrix, to reduce floating point operations</span>
        <span class="n">sparse_mat</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">)</span>

        <span class="c1"># # ## First, get the scipy solver result</span>
        <span class="c1"># eigenvalues, eigenvectors = sparse.linalg.eigs(</span>
        <span class="c1">#     sparse_mat.T, sigma=1, k=1, which=&quot;LR&quot;</span>
        <span class="c1"># )</span>
        <span class="c1"># max_eigval_index = np.argmax(np.real(eigenvalues))</span>
        <span class="c1"># algebraic_pss = np.real(eigenvectors[:, max_eigval_index]).squeeze()</span>
        <span class="c1">#</span>
        <span class="c1"># # and normalize it</span>
        <span class="c1"># algebraic_pss /= sum(algebraic_pss)</span>

        <span class="n">algebraic_pss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_algebraic</span><span class="p">(</span>
            <span class="n">max_iters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">check_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Get an initial flux estimate using the numpy algebraic solver</span>
        <span class="c1"># Call with _set=False so you don&#39;t actually update self.JtargetSS</span>
        <span class="n">last_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">(</span><span class="n">pSS</span><span class="o">=</span><span class="n">algebraic_pss</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># ## Next, use that as an initial guess  for inverse iteration</span>
        <span class="n">last_pSS</span> <span class="o">=</span> <span class="n">algebraic_pss</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial flux: </span><span class="si">{</span><span class="n">last_flux</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">flux_warned</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>

            <span class="n">iterated</span> <span class="o">=</span> <span class="n">inverse_iteration</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">sparse_mat</span><span class="p">,</span> <span class="n">guess</span><span class="o">=</span><span class="n">last_pSS</span><span class="p">)</span>

            <span class="c1"># Compute change in pSS</span>
            <span class="n">pSS_change</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">iterated</span> <span class="o">-</span> <span class="n">last_pSS</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Change in SS: </span><span class="si">{</span><span class="n">pSS_change</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">last_pSS</span> <span class="o">=</span> <span class="n">iterated</span>

            <span class="c1"># Compute change in target flux with the new pSS</span>
            <span class="n">new_flux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_steady_state_target_flux</span><span class="p">(</span><span class="n">pSS</span><span class="o">=</span><span class="n">last_pSS</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">flux_change</span> <span class="o">=</span> <span class="n">new_flux</span> <span class="o">-</span> <span class="n">last_flux</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Change in flux estimate: </span><span class="si">{</span><span class="n">flux_change</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> (</span><span class="si">{</span><span class="n">new_flux</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2"> raw)&quot;</span>
            <span class="p">)</span>
            <span class="n">last_flux</span> <span class="o">=</span> <span class="n">new_flux</span>

            <span class="c1"># Set the convergence criterion after the iteration, in case the original result is really junk</span>
            <span class="c1"># Do it after so the first time this is calculated, it&#39;s using the result of the first iteration.</span>
            <span class="c1"># If the initial numpy estimate was really bad, it&#39;ll never be used.</span>
            <span class="n">flux_convergence_criterion</span> <span class="o">=</span> <span class="n">last_flux</span> <span class="o">*</span> <span class="n">flux_fractional_convergence</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Flux convergence criterion is </span><span class="si">{</span><span class="n">flux_convergence_criterion</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">last_flux</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">flux_warned</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Flux is 0, so will only converge after max iterations. &quot;</span>
                        <span class="s2">&quot;If you&#39;re looking for equilibrium, this is probably OK.&quot;</span>
                        <span class="s2">&quot; Otherwise, take a look at why you have 0 flux.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">flux_warned</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">flux_change</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">flux_convergence_criterion</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Flux converged to </span><span class="si">{</span><span class="n">last_flux</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> after </span><span class="si">{</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2"> iterations of inverse iteration.&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">N</span> <span class="o">==</span> <span class="n">max_iters</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">last_flux</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Flux is nonzero and did not converge!&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">last_pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;Negative elements in pSS&quot;</span>
        <span class="k">assert</span> <span class="n">last_flux</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Negative flux estimate from this pSS&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;DONE&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">last_pSS</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_algebraic"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_algebraic">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_algebraic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">check_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the steady-state distribution as the eigenvectors of the transition matrix.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.pSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_iters: int, optional</span>
<span class="sd">            Defaults to 1000. Number of power-method iterations to run if the numpy eigensolver returns negative elements.</span>

<span class="sd">        check_negative: bool, optional</span>
<span class="sd">            Defaults to True. If True, then raise an Exception if there are negative elements in the normalized pSS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;get_steady_state_algebraic() will be deprecated soon. Use get_steady_state() instead, which has&quot;</span>
            <span class="s2">&quot; a more robust eigensolver.&quot;</span>
        <span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Computing steady-state from eigenvectors&quot;</span><span class="p">)</span>

        <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">))</span>

        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">))])</span>

        <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;Steady-state distribution sums to 0!&quot;</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>

        <span class="c1"># The numpy eigensolver is iterative, and approximate. Given that data from WE often spans many orders of</span>
        <span class="c1">#   magnitude, we&#39;ll sometimes run into situations where our populations span more than machine precision.</span>
        <span class="c1">#   This causes hiccups in the eigensolver. However, we can&#39;t just zero these out (as attempted above),</span>
        <span class="c1">#   because these values are often important.</span>
        <span class="c1"># So, if there are any negative elements, try to correct the NP eigensolver result using the matrix method</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pSS</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">max_iters</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Negative elements in pSS after normalization, attempting to correct with matrix power method.&quot;</span>
            <span class="p">)</span>
            <span class="n">pSS_last</span> <span class="o">=</span> <span class="n">pSS</span>
            <span class="n">_tmatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iters</span><span class="p">):</span>

                <span class="n">pSS_new</span> <span class="o">=</span> <span class="n">_tmatrix</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">pSS_last</span>
                <span class="n">num_negative_elements</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pSS_new</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">num_negative_elements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corrected to semidefinite pSS in </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> iterations&quot;</span><span class="p">)</span>
                    <span class="k">break</span>

                <span class="n">pSS_last</span> <span class="o">=</span> <span class="n">pSS_new</span>
                <span class="n">_tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">_tmatrix</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="n">max_iters</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Power method did NOT obtain semidefinite pSS. Some negative values remain. This is weird, and you&quot;</span>
                    <span class="s2">&quot; should try to figure out why this is happening.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS_new</span>

        <span class="k">elif</span> <span class="n">max_iters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s2">&quot;Negative elements in pSS after normalization, &quot;</span>
                <span class="s2">&quot;but max_iters=0 so not attempting to correct with power method.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">check_negative</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="n">pSS</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Some negative elements in steady-state distribution: </span><span class="si">{</span><span class="n">pSS</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Some negative  elements in pSS... Ignoring, and setting model.pSS anyways.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pSS</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_matrixpowers"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_matrixpowers">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_matrixpowers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the steady-state distribution using the matrix power method.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.pSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conv: numeric</span>
<span class="sd">            Convergence criterion for iteration.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">pSSp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">Mt</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSp</span><span class="p">))</span>
                <span class="n">pSSp</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;N=&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; dconv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="modelWE.get_steady_state_target_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_steady_state_target_flux">[docs]</a>    <span class="k">def</span> <span class="nf">get_steady_state_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pSS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_set</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the total flux into the target state(s).</span>

<span class="sd">        Updates:</span>
<span class="sd">            - `self.lagtime`</span>
<span class="sd">            - `self.JtargetSS`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pSS: (optional) array-like</span>
<span class="sd">            Steady-state distribution. If nothing provided, then use self.pSS</span>

<span class="sd">        _set: (optional) boolean</span>
<span class="sd">            If True, then update self.JtargetSS and self.lagtime. If False, then just return the value of JtargetSS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>

        <span class="c1"># If no pSS was provided, then pull from self</span>
        <span class="k">if</span> <span class="n">pSS</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">))</span>

        <span class="n">lagtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get a list of all the states that AREN&#39;T targets, since we want to sum up</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="c1"># log.debug(f&quot;Non-target states are those with index {indNotTargets}&quot;)</span>

        <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># Add up the total flux into each of the targets</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Processing flux into target state with index </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                    <span class="n">pSS</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">],</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Mss</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)])</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="n">lagtime</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">JtargetSS</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Jt</span> <span class="o">/</span> <span class="n">lagtime</span></div>

    <span class="k">def</span> <span class="nf">evolve_probability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition at basis</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">probBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="c1"># ????? why these nested excepts? What&#39;s so fragile here? Maybe the shape of pSS?</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">evolve_probability2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition spread for everything at RMSD higher than basis</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="n">probBasis</span><span class="p">[</span>
            <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span>
        <span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># assign initial probability to everything at RMSD higher than the basis, for case when nothing observed leaving exact basis</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">probBasis</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probBasis</span><span class="p">)</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="c1"># plt.ylim([1e-100,1])</span>
                <span class="c1"># plt.title(str(iT)+&#39; of &#39;+str(nIterations))</span>
                <span class="c1"># plt.pause(.1)</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">evolve_probability_from_initial</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">nEvolve</span><span class="p">,</span> <span class="n">nStore</span>
    <span class="p">):</span>  <span class="c1"># iterate nEvolve times, storing every nStore iterations, initial condition provided</span>
        <span class="n">nIterations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nEvolve</span> <span class="o">/</span> <span class="n">nStore</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nEvolve</span> <span class="o">=</span> <span class="n">nEvolve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">=</span> <span class="n">nStore</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span>
        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">probBasis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">probBasis</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">p0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">probBasis</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">probBasis</span> <span class="o">=</span> <span class="n">p0</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">probBasis</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="n">iT</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nIterations</span><span class="p">,</span> <span class="n">nBins</span><span class="p">))</span>  <span class="c1"># while dConv&gt;.00001:</span>
        <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">probBasis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">):</span>
            <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">pSS</span><span class="p">,</span> <span class="n">Mss</span><span class="p">)</span>
            <span class="n">dConv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pSS</span> <span class="o">-</span> <span class="n">pSSPrev</span><span class="p">))</span>
            <span class="n">pSSPrev</span> <span class="o">=</span> <span class="n">pSS</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">nStore</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;SS conv: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dConv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; iter: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">binCenters</span><span class="p">,</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">),</span>
                        <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                        <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                    <span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                            <span class="n">binCenters</span><span class="p">,</span>
                            <span class="n">pSS</span><span class="o">.</span><span class="n">A1</span><span class="p">,</span>
                            <span class="s2">&quot;-&quot;</span><span class="p">,</span>
                            <span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">Greys</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nEvolve</span><span class="p">)),</span>
                        <span class="p">)</span>
                    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e2</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                        <span class="k">pass</span>
                <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
                <span class="n">iT</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span> <span class="o">=</span> <span class="n">probTransient</span>
        <span class="n">pSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pSS</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pSS</span> <span class="o">=</span> <span class="n">pSS</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pSS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="modelWE.get_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_flux">[docs]</a>    <span class="k">def</span> <span class="nf">get_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the measured flux (i.e. from the flux matrix) into the target.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">indBack</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">indForward</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nBins</span><span class="p">)</span>
            <span class="n">JR</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">JF</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indBack</span><span class="p">:</span>
                <span class="n">JR</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indForward</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indForward</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indForward</span><span class="p">:</span>
                <span class="n">JF</span> <span class="o">=</span> <span class="n">JF</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indBack</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indBack</span><span class="p">)])</span>
            <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">-</span> <span class="n">JF</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">J</span></div>

<div class="viewcode-block" id="modelWE.get_flux_committor"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_flux_committor">[docs]</a>    <span class="k">def</span> <span class="nf">get_flux_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the flux binned according to committors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)</span>
        <span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">indq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">))</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indq</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fluxMatrix</span> <span class="o">=</span> <span class="n">fluxMatrix</span><span class="p">[:,</span> <span class="n">indq</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">indBack</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">indForward</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nBins</span><span class="p">)</span>
            <span class="n">JR</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">JF</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indBack</span><span class="p">:</span>
                <span class="n">JR</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indForward</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indForward</span><span class="p">)])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indForward</span><span class="p">:</span>
                <span class="n">JF</span> <span class="o">=</span> <span class="n">JF</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fluxMatrix</span><span class="p">[</span><span class="n">indBack</span><span class="p">,</span> <span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indBack</span><span class="p">)])</span>
            <span class="n">J</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">JR</span> <span class="o">-</span> <span class="n">JF</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Jq</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">plot_flux_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nwin</span><span class="p">):</span>

        <span class="n">nBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Jq_av</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Jq</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">Jq_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Jq_av</span><span class="p">)</span>
        <span class="n">q_av</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">Jq_av</span><span class="p">)</span>
        <span class="n">indq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nBins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nwin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">iav</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">nwin</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">nwin</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">Jq_av</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Jq</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="n">Jq_std</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Jq</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="n">q_av</span><span class="p">[</span><span class="n">iav</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">[</span><span class="n">indq</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">indPlus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jq_av</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">indMinus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Jq_av</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">q_av</span><span class="p">[</span><span class="n">indMinus</span><span class="p">],</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Jq_av</span><span class="p">[</span><span class="n">indMinus</span><span class="p">]),</span>
            <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;flux toward unfolded&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">q_av</span><span class="p">[</span><span class="n">indPlus</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">Jq_av</span><span class="p">[</span><span class="n">indPlus</span><span class="p">]),</span>
            <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;flux toward folded&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Committor&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Flux (weight/second&quot;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">modelName</span> <span class="o">+</span> <span class="s2">&quot;flux_committor.pdf&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="modelWE.plot_flux"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.plot_flux">[docs]</a>    <span class="k">def</span> <span class="nf">plot_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">custom_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make, and save, a plot of the fluxes along the RMSD.  get_flux() must be run before this.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        custom_name : str (optional)</span>
<span class="sd">            The name for the saved plot. Defaults to flux_s&lt;first iter&gt;_e&lt;last iter&gt;.png</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Fluxes not yet calculated -- run get_flux() before plot_flux().&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">indPlus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">indMinus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">J</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">binCenters</span><span class="p">[</span><span class="n">indPlus</span><span class="p">],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">indPlus</span><span class="p">]),</span>
            <span class="s2">&quot;ko&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;flux toward folded&quot;</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># ,color=plt.cm.Greys(float(iStep)/float(nStepFrames)))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">binCenters</span><span class="p">[</span><span class="n">indMinus</span><span class="p">],</span>
            <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="n">indMinus</span><span class="p">]),</span>
            <span class="s2">&quot;ro&quot;</span><span class="p">,</span>
            <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;flux toward unfolded&quot;</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># ,color=plt.cm.Reds(float(iStep)/float(nStepFrames)))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;flux (weight/second)&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Pcoord 1&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span>
            <span class="s2">&quot;Flux Run 1-30 Iter &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower right&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">custom_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;flux_s&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_e&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">custom_name</span>

        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">evolve_target_flux</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Mss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span>
        <span class="n">probTransient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">probTransient</span>
        <span class="n">nT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">probTransient</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Jtarget</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_lag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="n">JtargetTimes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nT</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nT</span><span class="p">):</span>
            <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
                <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="n">probTransient</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">indNotTargets</span><span class="p">],</span>
                        <span class="n">Mss</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)],</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">Jtarget</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jt</span>
            <span class="n">JtargetTimes</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">=</span> <span class="n">iT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nStore</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Jtarget</span> <span class="o">=</span> <span class="n">Jtarget</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagtime</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JtargetTimes</span> <span class="o">=</span> <span class="n">JtargetTimes</span>

    <span class="k">def</span> <span class="nf">get_hflux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="n">convh</span> <span class="o">=</span> <span class="n">conv</span>
        <span class="n">convf</span> <span class="o">=</span> <span class="n">conv</span>
        <span class="n">max_iters</span> <span class="o">=</span> <span class="mi">50000</span>
        <span class="n">nTargets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="o">.</span><span class="n">size</span>
        <span class="n">indNotTargets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">)</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dconvh</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">dconvf</span> <span class="o">=</span> <span class="mf">1.0e100</span>
        <span class="n">fTotal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fSSp</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">hp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">fTotal</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">dconvh</span> <span class="o">&gt;</span> <span class="n">convh</span> <span class="ow">or</span> <span class="n">dconvf</span> <span class="o">&gt;</span> <span class="n">convf</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="n">max_iters</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">):</span>
                <span class="n">Jt</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">Pt</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nTargets</span><span class="p">):</span>
                    <span class="n">jj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">Jt</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                            <span class="n">Pt</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">indNotTargets</span><span class="p">],</span>
                            <span class="n">Mt</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="n">jj</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">indNotTargets</span><span class="p">)],</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="n">fTotal</span> <span class="o">=</span> <span class="n">fTotal</span> <span class="o">+</span> <span class="n">f</span>
            <span class="n">fSS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">indNotTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">fTotal</span> <span class="o">-</span> <span class="n">N</span> <span class="o">*</span> <span class="n">fSS</span>
            <span class="n">dconvh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hp</span> <span class="o">-</span> <span class="n">ht</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>
            <span class="n">dconvf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fSS</span> <span class="o">-</span> <span class="n">fSSp</span><span class="p">)</span> <span class="o">/</span> <span class="n">fSS</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;N=&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; dh: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconvh</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; df: &quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconvf</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot; Jss:&quot;</span>
                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fSS</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">hp</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">fSSp</span> <span class="o">=</span> <span class="n">fSS</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">get_model_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
        <span class="n">kh_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">hsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">k_hsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">hsq</span><span class="p">)</span>
        <span class="n">varh</span> <span class="o">=</span> <span class="n">k_hsq</span> <span class="o">-</span> <span class="n">kh_sq</span>
        <span class="c1"># val=np.sqrt(varh)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varh</span> <span class="o">=</span> <span class="n">varh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh</span> <span class="o">=</span> <span class="n">kh</span>

    <span class="k">def</span> <span class="nf">get_model_steady_state_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;adaptive&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">cluster_kmeans</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nB</span><span class="p">:</span>
                <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;log_uniform&quot;</span><span class="p">:</span>
            <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;optimized&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="s2">&quot;khbins (khbins_binCenters.dat) not found: initializing</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins_equalAlloc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh_clusters&quot;</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;giving up: log uniform kh bins&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins</span><span class="p">()</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">nB</span>
        <span class="p">)</span>  <span class="c1"># get bin objective function, value and allocation over set of bins</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">indBin</span><span class="p">]))</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wt</span> <span class="o">*</span> <span class="p">(</span><span class="n">vw</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
                <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vw</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span>
        <span class="c1"># base_walkers=self.min_walkers*np.ones_like(alloc)</span>
        <span class="c1"># nBase=np.sum(base_walkers)</span>
        <span class="c1"># nAdapt=self.nW-nBase</span>
        <span class="c1"># if nAdapt&lt;0:</span>
        <span class="c1">#    nAdapt=0</span>
        <span class="c1"># walkers=np.round(alloc*nAdapt)</span>
        <span class="c1"># walkers=walkers+base_walkers</span>
        <span class="c1"># indZero=np.where(walkers==0.0)</span>
        <span class="c1"># walkers[indZero]=1.0</span>
        <span class="c1"># walkers=walkers.astype(int)</span>
        <span class="c1"># binEdges=np.zeros(self.nB+1)</span>
        <span class="c1"># binEdges[0]=-np.inf</span>
        <span class="c1"># binEdges[-1]=np.inf</span>
        <span class="c1"># ind=np.argsort(self.kh_clusters.clustercenters[:,0]) #note sorting makes kh_clusters indexes differen</span>
        <span class="c1"># self.khbins_binCenters=self.kh_clusters.clustercenters[ind,0]</span>
        <span class="c1"># binEdges[1:-1]=0.5*(self.khbins_binCenters[1:]+self.khbins_binCenters[0:-1])</span>
        <span class="c1"># self.khbins_binEdges=binEdges</span>
        <span class="c1"># self.walkers_per_bin=walkers[ind]</span>
        <span class="c1"># self.bin_kh_var=bin_kh_var[ind]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># asymptotic particle distribution in bins</span>
        <span class="c1"># asymptotic particle distribution after mutation</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
        <span class="n">rhov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">wv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBinv</span><span class="p">])</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;sum v: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">):</span>
                <span class="n">indBinu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">u</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">indBinv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">indBinu</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">rhov</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">rhov</span><span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
                            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">wv</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">Tmatrix</span><span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">]</span>
                        <span class="p">)</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rhov</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pOccupied</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span><span class="p">)</span>
        <span class="n">nOccupied</span> <span class="o">=</span> <span class="n">nB</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rho</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span><span class="p">))</span>
        <span class="n">nAdditional</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nOccupied</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span>
        <span class="n">nT</span> <span class="o">=</span> <span class="n">nAdditional</span> <span class="o">+</span> <span class="n">pOccupied</span>
        <span class="c1"># nT=np.zeros(nB)</span>
        <span class="c1"># for i in range(nB):</span>
        <span class="c1">#    nT[i]=np.max(np.array([1,nAdditional[i]+pOccupied[i]]))</span>
        <span class="n">bin_mutV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="n">bin_selV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
            <span class="n">bin_mutV</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">wi</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nT</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">bin_selV</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">wi</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nT</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
                <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pSS</span><span class="p">[</span><span class="n">indBin</span><span class="p">]</span> <span class="o">/</span> <span class="n">wi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">]),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_mutV</span> <span class="o">+</span> <span class="n">bin_selV</span><span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="c1"># self.walkers_per_bin=walkers[ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">base_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">nBase</span> <span class="o">=</span> <span class="n">nOccupied</span>  <span class="c1"># estimated from occupied bins a la Aristoff notes, was np.sum(base_walkers)</span>
        <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nBase</span>
        <span class="k">if</span> <span class="n">nAdapt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alloc</span> <span class="o">*</span> <span class="n">nAdapt</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span> <span class="o">+</span> <span class="n">base_walkers</span>
        <span class="n">indZero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">walkers</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">walkers</span><span class="p">[</span><span class="n">indZero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkers_per_bin</span> <span class="o">=</span> <span class="n">walkers</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_mutV</span> <span class="o">=</span> <span class="n">bin_mutV</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_selV</span> <span class="o">=</span> <span class="n">bin_selV</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nOccupancySS</span> <span class="o">=</span> <span class="n">nT</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nOccupied</span> <span class="o">=</span> <span class="n">nOccupied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nAdapt</span> <span class="o">=</span> <span class="n">nAdapt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rhomutation</span> <span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">get_initial_khbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># log-uniform kh bins</span>
        <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
            <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_initial_khbins_equalAlloc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># kh bins approximately of equal value</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_aristoffian</span><span class="p">()</span>
        <span class="n">binMethod_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span>
        <span class="n">allocationMethod_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span>
        <span class="n">nB_use</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;uniform&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="s2">&quot;adaptive&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">)</span>
        <span class="c1"># resN=np.round(abs(np.max(self.kh)/np.min(np.abs(self.kh)))).astype(int)</span>
        <span class="n">resN</span> <span class="o">=</span> <span class="mi">10000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="n">resN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_model_steady_state_aristoffian</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
        <span class="n">dist_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">kh_unique</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">xB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xB</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">indm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_unique</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">xB</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kh_unique</span><span class="p">[</span><span class="n">indm</span><span class="p">]</span>
            <span class="n">dist_unique</span><span class="p">[</span><span class="n">indm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">xB</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">=</span> <span class="n">nB_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="n">binMethod_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">=</span> <span class="n">allocationMethod_use</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
            <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>  <span class="c1"># note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[</span><span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bin_kh_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
        <span class="c1"># alloc=np.zeros(nB) #get bin objective function, value and allocation over set of bins</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># alloc[i]=0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="c1"># wt=np.sum(self.pSS[indBin])</span>
                <span class="c1"># vw=np.sum(np.multiply(self.pSS[indBin]/wt,self.varh[indBin]))</span>
                <span class="c1"># alloc[i]=wt*(vw)**.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_kh_var</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_bin_kh_var</span>

    <span class="k">def</span> <span class="nf">get_bin_total_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># nB = self.nB</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
            <span class="n">x</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">=</span> <span class="s2">&quot;optimized&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_model_steady_state_aristoffian</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span>

    <span class="k">def</span> <span class="nf">get_iter_aristoffian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">iter</span><span class="p">):</span>

        <span class="n">log</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span>
            <span class="s2">&quot;This function is untested, and may rely on other untested parts of this code. Use with extreme caution.&quot;</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_data</span><span class="p">(</span><span class="nb">iter</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;model_clusters&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_clusters</span><span class="p">()</span>
        <span class="c1">#        if self.pcoord_is_kh:</span>
        <span class="c1"># wt=np.sum(self.pSS[indBin])</span>
        <span class="c1"># vw=np.sum(np.multiply(self.pSS[indBin]/wt,self.varh[indBin]))</span>
        <span class="c1"># alloc[i]=wt*(vw)**.5</span>
        <span class="c1">#            self.khList=np.array(self.pcoord1List[:,1]) #kh is pcoord 2 from optimized WE sims</span>
        <span class="c1">#            self.khList=self.khList[:,np.newaxis]</span>
        <span class="c1">#        else:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># get k-means bins defined over walkers</span>
        <span class="n">nB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nB</span>
        <span class="n">khList_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">khList_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">nB</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;adaptive&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">coor</span><span class="o">.</span><span class="n">cluster_kmeans</span><span class="p">(</span>
                <span class="n">khList_unique</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">nB</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span>
            <span class="p">)</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">nB</span><span class="p">:</span>
                <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span> <span class="n">nB</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>  <span class="c1"># equal spacing if not enough for k-means</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;log_uniform&quot;</span><span class="p">:</span>
            <span class="n">transformedBins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="mf">1.0</span> <span class="o">+</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nB</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">khbins_binEdges_log</span> <span class="o">=</span> <span class="n">transformedBins</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">khbins</span> <span class="o">=</span> <span class="n">khbins_binEdges_log</span>  <span class="c1"># equal log-spacing</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">khbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">khbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">binMethod</span> <span class="o">==</span> <span class="s2">&quot;optimized&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">khbins_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s2">&quot;khbins_binCenters.dat&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;khbins (khbins_binCenters.dat) not found: initializing</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins_equalAlloc</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span> <span class="o">=</span> <span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span>
                    <span class="n">khbins_centers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>
                    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">n_jobs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;kh_clusters&quot;</span><span class="p">):</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;giving up: log uniform kh bins&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_initial_khbins</span><span class="p">()</span>
            <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dtraj_kh_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">)</span>
        <span class="n">varh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">varh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">nB</span>
        <span class="p">)</span>  <span class="c1"># get bin objective function, value and allocation over set of bins</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nB</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nB</span><span class="p">):</span>
            <span class="n">indBin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dtraj_kh_clusters</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">indBin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># n = indBin[0].size</span>
                <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">khList</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">indBin</span><span class="p">])</span>
                <span class="n">vw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weightList</span><span class="p">[</span><span class="n">indBin</span><span class="p">],</span> <span class="n">varh_iter</span><span class="p">[</span><span class="n">indBin</span><span class="p">]))</span>
                <span class="n">alloc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wt</span> <span class="o">*</span> <span class="n">vw</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocationMethod</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">alloc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alloc</span> <span class="o">=</span> <span class="n">alloc</span>
        <span class="n">base_walkers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_walkers</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
        <span class="n">nBase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">base_walkers</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;nAdapt&quot;</span><span class="p">):</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nAdapt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nW</span> <span class="o">-</span> <span class="n">nBase</span>
        <span class="k">if</span> <span class="n">nAdapt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nAdapt</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">alloc</span> <span class="o">*</span> <span class="n">nAdapt</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span> <span class="o">+</span> <span class="n">base_walkers</span>
        <span class="n">indZero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">walkers</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">walkers</span><span class="p">[</span><span class="n">indZero</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">khbins_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">khbins_centers_unique</span><span class="p">,</span> <span class="n">ind_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">khbins_centers</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">walkers</span> <span class="o">=</span> <span class="n">walkers</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span><span class="p">[</span><span class="n">ind_unique</span><span class="p">]</span>
        <span class="n">binEdges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">khbins_centers_unique</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># ind=np.argsort(khbins_centers_unique) #note sorting makes kh_clusters indexes different</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span> <span class="o">=</span> <span class="n">khbins_centers_unique</span>  <span class="c1"># [ind]</span>
        <span class="n">binEdges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binCenters</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">khbins_binEdges</span> <span class="o">=</span> <span class="n">binEdges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">walkers_per_bin</span> <span class="o">=</span> <span class="n">walkers</span>  <span class="c1"># [ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_kh_var</span> <span class="o">=</span> <span class="n">bin_kh_var</span>  <span class="c1"># [ind]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binObjective</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_kh_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_iter_kh_pcoord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># grab coordinates from WE traj_segs folder</span>
        <span class="n">nS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;model_clusters&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_model_clusters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates</span><span class="p">()</span>  <span class="c1"># post coordinates</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">khList1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># post pcoord</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_iter_coordinates0</span><span class="p">()</span>  <span class="c1"># pre coordinates</span>
        <span class="n">dtraj_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reduceCoordinates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_iter_coords</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">kh_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kh</span><span class="p">[</span><span class="n">dtraj_iter</span><span class="p">]</span>
        <span class="n">khList0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kh_iter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># pre pcoord</span>
        <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># this is explicitly set up for p1 (target,basis def) and p2 (kh-aristoffian)</span>
        <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nSeg</span><span class="p">):</span>
            <span class="n">westFile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fileList</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]]</span>
            <span class="n">pcoord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord0List</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcoord1List</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">khList0</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoord</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">khList1</span><span class="p">[</span><span class="n">iS</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">pcoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iS</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">westList</span><span class="p">[</span><span class="n">iS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">iS</span> <span class="o">&lt;</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span>
                            <span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pcoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:])</span>
                        <span class="p">)</span>
                        <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pcoords</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">)</span>  <span class="c1"># this is explicitly set up for p1 (target,basis def) and p2 (kh-aristoffian)</span>
                        <span class="n">pcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcoords</span><span class="p">,</span> <span class="n">pcoord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">dataIn</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">westFile</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">iS</span> <span class="o">==</span> <span class="n">nS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dsetName</span> <span class="o">=</span> <span class="s2">&quot;/iterations/iter_</span><span class="si">%08d</span><span class="s2">/pcoord&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">dataIn</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                        <span class="n">dset</span> <span class="o">=</span> <span class="n">dataIn</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pcoords</span><span class="p">))</span>
                        <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pcoords</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                            <span class="s2">&quot;pcoords for iteration &quot;</span>
                            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                            <span class="o">+</span> <span class="s2">&quot; overwritten</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="p">)</span>
                        <span class="n">dataIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;error overwriting pcoord from &quot;</span>
                    <span class="o">+</span> <span class="n">westFile</span>
                    <span class="o">+</span> <span class="s2">&quot; , iter &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; segment &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">segindList</span><span class="p">[</span><span class="n">iS</span><span class="p">])</span>
                    <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="p">)</span>

<div class="viewcode-block" id="modelWE.get_committor"><a class="viewcode-back" href="../../api.html#msm_we.msm_we.modelWE.get_committor">[docs]</a>    <span class="k">def</span> <span class="nf">get_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iteratively obtain an estimate of the committor.</span>

<span class="sd">        1. Take the flux matrix, and normalize it into a transition matrix.</span>

<span class="sd">        2. Apply two-sided absorbing boundary conditions by setting self-transition probabilities for the basis and</span>
<span class="sd">            target states to 1.0, and all transitions out to 0.0.</span>

<span class="sd">        3. Starting with an initial committor &quot;guess&quot; of all 1s, iteratively multiply the guess by the transition matrix</span>
<span class="sd">            until convergence is below conv.</span>

<span class="sd">        Updates:</span>
<span class="sd">            - self.q</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        conv: numerical</span>
<span class="sd">            Convergence criteria for committor calculation. Calculation stops when the total difference between q_p and q</span>
<span class="sd">            is less than this.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_fluxMatrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Number of bins/states in the fluxmatrix</span>

        <span class="n">num_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">)</span>
        <span class="n">flux_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

            <span class="c1"># If the flux out is positive semidefinite, then normalize that row to get transition probabilities</span>
            <span class="k">if</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>

            <span class="c1"># If the flux out is zero, then just set the self-transition to 1.0</span>
            <span class="c1"># (This probably keeps a calculation later clean?)</span>
            <span class="k">if</span> <span class="n">flux_out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1">#  The basis states are set to have 0 flux out, and only self-transition = 1.0.</span>
        <span class="c1">#   These are the two-sided absorbing BCs for the committor.</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">sinkBins</span><span class="p">:</span>
            <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
            <span class="n">_fluxMatrix</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Committor to the target state is 1 by definition</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="n">qp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># Iteratively update the committor estimate until it converges to stationarity</span>
        <span class="c1"># (The committor is the stationary distribution for two-sided absorbing boundary conditions)</span>
        <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span><span class="p">:</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">_fluxMatrix</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="n">q</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;convergence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>

    <span class="c1"># TODO: This should probably just be a call to get_committor, followed by self.q = 1 - self.q</span>
    <span class="k">def</span> <span class="nf">get_backwards_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conv</span><span class="p">):</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fluxMatrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
        <span class="n">sM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nR</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sM</span><span class="p">[</span><span class="n">iR</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">Mt</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">sinkBins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span>  <span class="c1"># np.where(avBinPnoColor==0.0)</span>
        <span class="n">nsB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sinkBins</span><span class="p">)</span>
        <span class="n">nsB</span> <span class="o">=</span> <span class="n">nsB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">sinkBins</span><span class="p">:</span>
            <span class="n">Mt</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">))</span>
            <span class="n">Mt</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>  <span class="c1"># time reversal</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nBins</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">dconv</span> <span class="o">=</span> <span class="mf">100.0</span>
        <span class="n">qp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">dconv</span> <span class="o">&gt;</span> <span class="n">conv</span><span class="p">:</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indBasis</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="n">q</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indTargets</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Mt</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">dconv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qp</span> <span class="o">-</span> <span class="n">q</span><span class="p">))</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;convergence: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dconv</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">qp</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qm</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">plot_committor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binCenters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Folding Committor&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Average microstate pcoord&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">modelName</span>
            <span class="o">+</span> <span class="s2">&quot;_s&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">first_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;_e&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">last_iter</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot;committor.png&quot;</span>
        <span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, John Russo.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>